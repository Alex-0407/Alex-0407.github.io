<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>artdong的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/artdong/"/>
  <updated>2019-07-23T06:27:19.952Z</updated>
  <id>https://github.com/artdong/</id>
  
  <author>
    <name>扫码关注</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说说你对Promise的理解？</title>
    <link href="https://github.com/artdong/2019/07/06/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/artdong/2019/07/06/说说你对Promise的理解/</id>
    <published>2019-07-06T09:30:11.000Z</published>
    <updated>2019-07-23T06:27:19.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="Promise-核心"><a href="#Promise-核心" class="headerlink" title="Promise 核心"></a>Promise 核心</h2><ul><li>Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要）</li><li>Promise 规范中规定了，promise 的状态只有3种：<ul><li>pending</li><li>fulfilled</li><li>rejected<br>Promise 的状态一旦改变则不会再改变。</li></ul></li><li><p>Promise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。</p><hr></li></ul> <a id="more"></a><h2 id="ES6-Promise细节"><a href="#ES6-Promise细节" class="headerlink" title="ES6 Promise细节"></a>ES6 Promise细节</h2><ul><li>Promise 构造器中必须传入函数，否则会抛出错误。(没有执行器还怎么做异步操作。。。)</li><li>Promise.prototype上的 catch(onrejected) 方法是 then(null,onrejected) 的别名,并且会处理链之前的任何的reject。</li><li>Promise.prototype 上的 then和 catch 方法总会返回一个全新的 Promise 对象。</li><li>如果传入构造器的函数中抛出了错误,该 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。</li><li>then 中的回调如果抛出错误，返回的 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。</li><li>then 中的回调返回值会影响 then 返回的 promise 对象。</li></ul><h2 id="Promise优点"><a href="#Promise优点" class="headerlink" title="Promise优点"></a>Promise优点</h2><ul><li>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了。</li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/1027242914217888/l" alt="promise.gif"></p><ul><li>解决回调地狱（Callback Hell）问题 </li></ul><p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。</p><p>要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br></pre></td></tr></table></figure><blockquote><p>其中，job1、job2和job3都是Promise对象。</p></blockquote><ul><li><p>Promise.all()并行执行异步任务</p></li><li><p>Promise.race()获得先返回的结果即可</p></li></ul><blockquote><p>eg.同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。</p></blockquote><h2 id="Promise如何解决这两个问题"><a href="#Promise如何解决这两个问题" class="headerlink" title="Promise如何解决这两个问题"></a>Promise如何解决这两个问题</h2><ul><li>解决可读性的问题</li></ul><p>这一点不用多说，用过Promise的人很容易明白。Promise的应用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。</p><ul><li>解决信任问题</li></ul><p>Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。</p><p>这种机制有点像事件的触发。它与普通的回调的方式的区别在于，普通的方式，回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。在Promise的方式中，回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。</p><p>Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。</p><p>对于回调过早的问题，由于Promise只能是异步的，所以不会出现异步的同步调用。即便是在决议之前的错误，也是异步的，并不是会产生同步（调用过早）的困扰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let a = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  let b = 1 + c;  // ReferenceError: c is not defined，错误会在下面的a打印出来之后报出。</span><br><span class="line">  resolve(true);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1, a);</span><br><span class="line">a.then(res =&gt; &#123;</span><br><span class="line">  console.log(2, res);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>对于回调过晚或没有调用的问题，Promise本身不会回调过晚，只要决议了，它就会按照规定运行。至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function timeoutPromise(delay) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      reject(&quot;Timeout!&quot;);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race([doSomething(), timeoutPromise(3000)])</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...);</span><br></pre></td></tr></table></figure></p><p>对于回调次数太少或太多的问题，由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Promise-核心&quot;&gt;&lt;a href=&quot;#Promise-核心&quot; class=&quot;headerlink&quot; title=&quot;Promise 核心&quot;&gt;&lt;/a&gt;Promise 核心&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要）&lt;/li&gt;
&lt;li&gt;Promise 规范中规定了，promise 的状态只有3种：&lt;ul&gt;
&lt;li&gt;pending&lt;/li&gt;
&lt;li&gt;fulfilled&lt;/li&gt;
&lt;li&gt;rejected&lt;br&gt;Promise 的状态一旦改变则不会再改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Promise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>promise和setTimeout执行顺序是怎样的？</title>
    <link href="https://github.com/artdong/2019/07/05/promise%E5%92%8CsetTimeout%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
    <id>https://github.com/artdong/2019/07/05/promise和setTimeout执行顺序是怎样的/</id>
    <published>2019-07-05T09:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><p>写出下列程序运行结果并做出解释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span> ; i++ ) &#123; </span><br><span class="line">        i==<span class="number">9999</span> &amp;&amp; resolve(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>) </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><hr> <a id="more"></a><p>这个就涉及到<strong>事件循环（Event Loop）</strong></p><blockquote><p>JS运行时，对代码执行顺序的一个算法（任务调度算法）</p></blockquote><p>JS 分类：同步任务和异步任务<br>JS 的执行机制：</p><ul><li>首先判断JS代码是同步还是异步，同步就进入主线程，异步就进入 event table</li><li>异步任务在 event table 中注册函数，当满足触发条件后，被推入event queue</li><li>同步任务进入主线程后一直执行，直到主线程空闲时，才回去 event queue 中查看是否有可执行的异步任务，如果有就推入主线程</li></ul><p>event loop 里有维护两个不同的异步任务队列</p><ul><li>macro Tasks（宏任务）：script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering</li><li>micro Tasks（微任务）：process.nextTick, Promise（浏览器实现的原生Promise）, Object.observe,  MutationObserver, MessageChannel</li></ul><p>每次执行一段代码（一个script标签）都是一个 macroTask<br>执行流程：</p><ul><li>event loop 开始</li><li>从macro Tasks 队列抽取一个任务，执行</li><li>micro Tasks 清空队列执行，若有任务不可执行，推入下一轮 micro Tasks</li><li>结束 event loop</li></ul><p>浏览器执行代码的过程如下整个流程<br><img src="https://user-images.githubusercontent.com/18480722/60965123-9f2c5900-a347-11e9-81d5-e93ec6c60840.png" alt="image"></p><p>那么回到题目上去，就是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);    <span class="comment">// 1-放入宏任务队列，7-执行下一轮事件循环，宏任务输出1</span></span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);    <span class="comment">// 2-同步输出 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span> ; i++ ) &#123; </span><br><span class="line">        i==<span class="number">9999</span> &amp;&amp; resolve(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);    <span class="comment">// 4-同步输出 3</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);    <span class="comment">// 3-放入微任务队列，6-回到微任务队列，执行剩余的微任务，输出4</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);    <span class="comment">// 5-同步输出 5</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;p&gt;写出下列程序运行结果并做出解释：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt; ; i++ ) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i==&lt;span class=&quot;number&quot;&gt;9999&lt;/span&gt; &amp;amp;&amp;amp; resolve(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？</title>
    <link href="https://github.com/artdong/2019/07/04/Object.assign%20%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>https://github.com/artdong/2019/07/04/Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些/</id>
    <published>2019-07-04T09:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><blockquote><p> Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p></blockquote><ul><li><p>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p></li><li><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p></li><li><p>String类型和 Symbol 类型的属性都会被拷贝。</p></li><li><p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。</p></li><li><p>Object.assign 不会在那些source对象值为 <code>null</code>或 <code>undefined</code> 的时候抛出错误。</p></li><li><p>针对<strong>深拷贝</strong>，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为<code>深拷贝</code>；如果属性值为对象或其它引用类型，那对于这个对象而言其实是<code>浅拷贝</code>的。</p><hr></li></ul> <a id="more"></a><h2 id="深拷贝的几种实现方法"><a href="#深拷贝的几种实现方法" class="headerlink" title="深拷贝的几种实现方法"></a>深拷贝的几种实现方法</h2><h3 id="JSON-stringify-和-JSON-parse"><a href="#JSON-stringify-和-JSON-parse" class="headerlink" title="JSON.stringify 和 JSON.parse"></a>JSON.stringify 和 JSON.parse</h3><blockquote><p>用 JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。</p></blockquote><p>可以转成 JSON 格式的对象才能使用这种方法，如果对象中包含 function 或 RegExp 这些就不能用这种方法了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//通过js的内置对象JSON来进行数组对象的深拷贝</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  let _obj = JSON.stringify(obj);</span><br><span class="line">  let objClone = JSON.parse(_obj);</span><br><span class="line">  return objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign-拷贝"><a href="#Object-assign-拷贝" class="headerlink" title="Object.assign()拷贝"></a>Object.assign()拷贝</h3><p>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</p><h3 id="通过jQuery的extend方法实现深拷贝"><a href="#通过jQuery的extend方法实现深拷贝" class="headerlink" title="通过jQuery的extend方法实现深拷贝"></a>通过jQuery的extend方法实现深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let $ = require(&apos;jquery&apos;);</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: &#123;</span><br><span class="line">     f: &#123;</span><br><span class="line">       g: 1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = $.extend(true, &#123;&#125;, obj1);</span><br></pre></td></tr></table></figure><h3 id="lodash-cloneDeep-实现深拷贝"><a href="#lodash-cloneDeep-实现深拷贝" class="headerlink" title="lodash.cloneDeep()实现深拷贝"></a>lodash.cloneDeep()实现深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let _ = require(&apos;lodash&apos;);</span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure><h3 id="使用递归的方式实现深拷贝"><a href="#使用递归的方式实现深拷贝" class="headerlink" title="使用递归的方式实现深拷贝"></a>使用递归的方式实现深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function _deepClone(source) &#123;</span><br><span class="line">  let target;</span><br><span class="line">  if (typeof source === &apos;object&apos;) &#123;</span><br><span class="line">    target = Array.isArray(source) ? [] : &#123;&#125;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">      if (source.hasOwnProperty(key)) &#123;</span><br><span class="line">        if (typeof source[key] !== &apos;object&apos;) &#123;</span><br><span class="line">          target[key] = source[key]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          target[key] = _deepClone(source[key])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    target = source</span><br><span class="line">  &#125;</span><br><span class="line">  return target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt; Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String类型和 Symbol 类型的属性都会被拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Object.assign 不会在那些source对象值为 &lt;code&gt;null&lt;/code&gt;或 &lt;code&gt;undefined&lt;/code&gt; 的时候抛出错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对&lt;strong&gt;深拷贝&lt;/strong&gt;，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为&lt;code&gt;深拷贝&lt;/code&gt;；如果属性值为对象或其它引用类型，那对于这个对象而言其实是&lt;code&gt;浅拷贝&lt;/code&gt;的。&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>css常用的清除浮动方法有哪些？</title>
    <link href="https://github.com/artdong/2019/07/03/css%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>https://github.com/artdong/2019/07/03/css常用的清除浮动方法有哪些/</id>
    <published>2019-07-03T09:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><ul><li><p>父级元素添加伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear-float</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li></ul> <a id="more"></a><ul><li><p>在与浮动元素平级的最后面添加新元素 div.clear</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在父级元素添加样式 overflow: auto; 或者 overflow: hidden; 会存在兼容性问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;父级元素添加伪元素&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.clear-float&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:after&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;content&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;clear&lt;/span&gt;: both;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="https://github.com/artdong/categories/css/"/>
    
    
      <category term="css" scheme="https://github.com/artdong/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js实现几种常见排序算法</title>
    <link href="https://github.com/artdong/2019/07/02/js%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/artdong/2019/07/02/js实现几种常见排序算法/</id>
    <published>2019-07-02T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.544Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><p>js实现几种常见排序算法。</p><p>冒泡排序：</p><p><img src="https://upload-images.jianshu.io/upload_images/3100736-d38281a90f05aff1.gif?imageMogr2/auto-orient/strip" alt="bubbleSort.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">let</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure><hr> <a id="more"></a><p>冒泡排序优化版： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">let</span> sortBorder = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">let</span> isSorted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; sortBorder - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">let</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    isSorted = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span>(isSorted) &#123; <span class="comment">//有序,跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure><p>选择排序：</p><p><img src="https://upload-images.jianshu.io/upload_images/3100736-6bb5d8693bc99a16.gif?imageMogr2/auto-orient/strip" alt="selectSort.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line"></span><br><span class="line">function selectionSort(arr) &#123; </span><br><span class="line">    let len = arr.length;</span><br><span class="line">    let minIndex, temp;</span><br><span class="line">    for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123; </span><br><span class="line">                // 寻找最小的数</span><br><span class="line">                minIndex = j; </span><br><span class="line">                // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i]; </span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp; </span><br><span class="line">    &#125; </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(selectionSort(arr));</span><br></pre></td></tr></table></figure><p>选择排序优化版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> max = left;<span class="comment">//记录无序区最大元素下标</span></span><br><span class="line">        <span class="keyword">let</span> min = left;<span class="comment">//记录无序区最小元素下标</span></span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="comment">//找最大元素下标</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找最小元素下标</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[max])</span><br><span class="line">            &#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小值如果是第一个则没有必要交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != left) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = arr[left];</span><br><span class="line">            arr[left] = arr[min];</span><br><span class="line">            arr[min] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里很重要，如果最大元素下标是left,前面已经和最小元素交换了，此时最大元素下标应该是min</span></span><br><span class="line">        <span class="keyword">if</span> (max == left) &#123;</span><br><span class="line">            max = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大值如果是最后一个则没必要交换</span></span><br><span class="line">        <span class="keyword">if</span> (max != right) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = arr[right];</span><br><span class="line">            arr[right] = arr[max];</span><br><span class="line">            arr[max] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(selectionSort(arr));</span><br></pre></td></tr></table></figure><p>插入排序：</p><p><img src="https://upload-images.jianshu.io/upload_images/3100736-551606266d9282a5.gif?imageMogr2/auto-orient/strip" alt="insertSort1.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line"></span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    const len = arr.length;</span><br><span class="line">    let preIndex, current;</span><br><span class="line">    for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(insertSort(arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;p&gt;js实现几种常见排序算法。&lt;/p&gt;
&lt;p&gt;冒泡排序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3100736-d38281a90f05aff1.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;bubbleSort.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;47&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;46&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; len = arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(len &amp;gt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; len - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j &amp;lt; len - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; - i; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[j] &amp;gt; arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; temp = arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    arr[j] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(bubbleSort(arr));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS 数据类型有哪些？</title>
    <link href="https://github.com/artdong/2019/07/01/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B7+3/"/>
    <id>https://github.com/artdong/2019/07/01/JS数据类型有哪些7+3/</id>
    <published>2019-07-01T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><p>JS 7 种基本数据类型（原始类型），即 （Undefined、Null、Boolean、Number 、String） + （Symbol、BigInt）和 3种引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p><p>基本类型值：指的是保存在栈内存中的简单数据段。</p><p>引用类型值：指的是那些保存在堆内存中的对象。变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值。</p><blockquote><p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值; BigInt即是第七种基本类型，V8引擎v6.7 默认启用对 BigInt 的支持。</p></blockquote><hr> <a id="more"></a><p>Symbol用法 </p><p>语法  </p><p>Symbol (value)</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=Symbol (&quot;welcome&quot;);</span><br><span class="line">console.log(a); //输出 Symbol(welcome)</span><br></pre></td></tr></table></figure><p>BigInt用法  </p><p>语法  </p><p>BigInt(value) || 数字后面加n;</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let b1 = BigInt(10);</span><br><span class="line">let b2 = 10n;</span><br><span class="line">console.log(b1,b2); //输出 10n 10n</span><br></pre></td></tr></table></figure><hr><p>更多<a href="https://github.com/daily-interview/fe-interview">经典前端面试题</a>，请到github查看或参与讨论<a href="https://github.com/daily-interview/fe-interview">https://github.com/daily-interview/fe-interview</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;p&gt;JS 7 种基本数据类型（原始类型），即 （Undefined、Null、Boolean、Number 、String） + （Symbol、BigInt）和 3种引用数据类型：对象(Object)、数组(Array)、函数(Function)。&lt;/p&gt;
&lt;p&gt;基本类型值：指的是保存在栈内存中的简单数据段。&lt;/p&gt;
&lt;p&gt;引用类型值：指的是那些保存在堆内存中的对象。变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值; BigInt即是第七种基本类型，V8引擎v6.7 默认启用对 BigInt 的支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSS - 定位属性position使用详解（static、relative、fixed、absolute）</title>
    <link href="https://github.com/artdong/2018/07/23/css-position/"/>
    <id>https://github.com/artdong/2018/07/23/css-position/</id>
    <published>2018-07-23T02:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.541Z</updated>
    
    <content type="html"><![CDATA[ <h3 id="position 属性介绍"> position 属性介绍 </h3>（1）position 属性自 CSS2 起就有了，该属性规定元素的定位类型。所有主流浏览器都支持 position 属性。（2）position 的可选值有四个：static、relative、absolute、fixed。下面分别进行介绍。（其实还有个 inherit，不过这个是 IE 特有的，这里就不做讨论） <a id="more"></a><h3 id="position: static（默认值）"> position: static（默认值）</h3>1，基本介绍（1）static 是默认值。表示没有定位，或者说不算具有定位属性。（2）如果元素 position 属性值为 static（或者未设 position 属性），该元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。2，使用样例css: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: #C9FFFF;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>html: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot;/&gt;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>我们不设置元素的 postion 属性值，那么默认的显示效果如下：<div class="position-static"></div> <input type="text"><h3 id="position: relative（相对定位）"> position: relative（相对定位）</h3>1，基本介绍（1）relative 生成相对定位的元素，相对于其正常位置进行定位。（2）相对定位完成的过程如下：    首先按默认方式（static）生成一个元素(并且元素像层一样浮动了起来)。    然后相对于以前的位置移动，移动的方向和幅度由 left、right、top、bottom 属性确定，偏移前的位置保留不动。2，样例代码下面代码将文本输入框 position 设置为 relative（相对定位），并且相对于默认的位置向右、向上分别移动 15 个像素。css:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: #C9FFFF;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">input &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  left: 15px;</span><br><span class="line">  top: -15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> html: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure>运行效果如下：<div class="position-relative"></div> <input type="text" class="position-relative-input"><h3 id="position: absolute（绝对定位）"> position: absolute（绝对定位）</h3>1，基本介绍（1）absolute 生成绝对定位的元素。（2）绝对定位的元素使用 left、right、top、bottom 属性相对于其最接近的一个具有定位属性的父元素进行绝对定位。（3）如果不存在这样的父元素，则相对于 body 元素，即相对于浏览器窗口。2，样例代码    下面代码让标题元素相对于它的父容器做绝对定位（注意父容器 position 要设置为 relative）。    同时通过 top 属性让标题元素上移，使其覆盖在父容器的上边框。    最后通过 left 和 margin-left 配合实现这个绝对定位元素的水平居中。css:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#box &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  -webkit-box-flex:1;</span><br><span class="line">  border: 1px solid #28AE65;</span><br><span class="line">  border-radius:6px;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  position: relative;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#title &#123;</span><br><span class="line">  background: #FFFFFF;</span><br><span class="line">  color: #28AE65;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  width: 70px;</span><br><span class="line">  height: 20px;</span><br><span class="line">  line-height: 20px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: -10px;</span><br><span class="line">  left: 50%;</span><br><span class="line">  margin-left: -35px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>html: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;title&quot;&gt;标题&lt;/div&gt;</span><br><span class="line">  欢迎访问我的博客</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>运行效果如下，标题元素虽然是在边框容器的内部。但由于其使用绝对定位，并做位置调整，最后显示效果就是覆盖在父容器边框上。<br><br><div class="position-absolute">  <div class="position-absolute-title">标题</div>  嘿，guys！欢迎访问我的博客。</div><h3 id="position: fixed（固定定位）"> position: fixed（固定定位）</h3>1，基本介绍（1）fixed 生成绝对定位的元素，该元素相对于浏览器窗口进行定位。（2）固定定位的元素不会随浏览器窗口的滚动条滚动而变化，也不会受文档流动影响，而是始终位于浏览器窗口内视图的某个位置。2，样例代码（1）下面代码让输入框位于浏览器窗口的底部。css:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  bottom: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>html: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure>（2）可以看到不管滚动条如何滚动，输入框始终处于窗口的最下方。<ol>  <li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li>  <li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li>  <li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li>  <li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li><li>数据</li></ol><input type="text" class="position-fixed-input" placeholder="look here, fixed input">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;position 属性介绍&quot;&gt; position 属性介绍 &lt;/h3&gt;

（1）position 属性自 CSS2 起就有了，该属性规定元素的定位类型。所有主流浏览器都支持 position 属性。

（2）position 的可选值有四个：static、relative、absolute、fixed。下面分别进行介绍。（其实还有个 inherit，不过这个是 IE 特有的，这里就不做讨论）
    
    </summary>
    
      <category term="css" scheme="https://github.com/artdong/categories/css/"/>
    
    
      <category term="css" scheme="https://github.com/artdong/tags/css/"/>
    
      <category term="css3" scheme="https://github.com/artdong/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>angular2组件之间的交互</title>
    <link href="https://github.com/artdong/2018/06/08/angular2%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>https://github.com/artdong/2018/06/08/angular2组件之间的交互/</id>
    <published>2018-06-08T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="通过输入型绑定把数据从父组件传到子组件。"><a href="#通过输入型绑定把数据从父组件传到子组件。" class="headerlink" title="通过输入型绑定把数据从父组件传到子组件。"></a>通过输入型绑定把数据从父组件传到子组件。</h2><p>HeroChildComponent 有两个输入型属性，它们通常带@Input 装饰器。<br>component-interaction/src/app/hero-child.component.ts</p><pre><code>import { Component, Input } from &apos;@angular/core&apos;;import { Hero } from &apos;./hero&apos;;@Component({  selector: &apos;app-hero-child&apos;,  template: `    &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt;    &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt;  `})export class HeroChildComponent {  @Input() hero: Hero;  @Input(&apos;master&apos;) masterName: string;}</code></pre><p>第二个 @Input 为子组件的属性名 masterName 指定一个别名 master(译者注：不推荐为起别名，请参见风格指南).</p><p>父组件 HeroParentComponent 把子组件的 HeroChildComponent 放到 *ngFor 循环器中，把自己的 master 字符串属性绑定到子组件的 master 别名上，并把每个循环的 hero 实例绑定到子组件的 hero 属性。<br>component-interaction/src/app/hero-parent.component.ts</p><pre><code>import { Component } from &apos;@angular/core&apos;;import { HEROES } from &apos;./hero&apos;;@Component({  selector: &apos;app-hero-parent&apos;,  template: `    &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt;    &lt;app-hero-child *ngFor=&quot;let hero of heroes&quot;      [hero]=&quot;hero&quot;      [master]=&quot;master&quot;&gt;    &lt;/app-hero-child&gt;  `})export class HeroParentComponent {  heroes = HEROES;  master = &apos;Master&apos;;}</code></pre><hr> <a id="more"></a><h2 id="Angular-2-架构"><a href="#Angular-2-架构" class="headerlink" title="Angular 2 架构"></a>Angular 2 架构</h2><p>Angular 2 应用程序应用主要由以下 8 个部分组成：</p><p>1、模块 (Modules)</p><p>2、组件 (Components)</p><p>3、模板 (Templates)</p><p>4、元数据 (Metadata)</p><p>5、数据绑定 (Data Binding)</p><p>6、指令 (Directives)</p><p>7、服务 (Services)</p><p>8、依赖注入 (Dependency Injection)</p><p>下面看每个部分是如何相互工作的：</p><p>模板 (Templates)是由 Angular 扩展的 HTML 语法组成，组件 (Components)类用来管理这些模板，应用逻辑部分通过服务 (Services)来完成，然后在模块中打包服务与组件，最后通过引导根模块来启动应用。</p><p>接下来对以上 8 个部分分开解析：</p><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1.模块"></a>1.模块</h3><p>模块又一块代码组成，可用于执行一个简单的任务。</p><p>Angular 应用是由模块化的，它有自己的模块系统：NgModules。</p><p>每个 Angular 应该至少要有一个模块(根模块)，一般可以命名为：AppModule。</p><p>Angular 模块是一个带有 @NgModule 装饰器的类，它接收一个用来描述模块属性的元数据对象。</p><p>几个重要的属性如下：</p><p>declarations （声明）- 视图类属于这个模块。 Angular 有三种类型的视图类： 组件 、 指令 和 管道 。</p><p>exports- 声明（ declaration ）的子集，可用于其它模块中的组件模板 。</p><p>imports- 本模块组件模板中需要由其它导出类的模块。</p><p>providers- 服务的创建者。本模块把它们加入全局的服务表中，让它们在应用中的任何部分都可被访问到。</p><p>bootstrap- 应用的主视图，称为根组件，它是所有其它应用视图的宿主。只有根模块需要设置 bootstrap 属性中。</p><p>一个最简单的根模块，eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;NgModule&#125;<span class="keyword">from</span><span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;BrowserModule&#125;<span class="keyword">from</span><span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;<span class="attr">imports</span>: [BrowserModule],</span><br><span class="line"></span><br><span class="line">providers: [Logger],</span><br><span class="line"></span><br><span class="line">declarations: [AppComponent],</span><br><span class="line"></span><br><span class="line">exports: [AppComponent],</span><br><span class="line"></span><br><span class="line">bootstrap: [AppComponent]&#125;)exportclassAppModule&#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来通过引导根模块来启动应用，开发过程通常在 main.ts 文件中来引导 AppModule ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;platformBrowserDynamic&#125;<span class="keyword">from</span><span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;AppModule&#125;<span class="keyword">from</span><span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><h3 id="2-组件-Components"><a href="#2-组件-Components" class="headerlink" title="2.组件(Components)"></a>2.组件(Components)</h3><p>组件是一个模板的控制类用于处理应用和逻辑页面的视图部分。</p><p>组件是构成 Angular 应用的基础和核心，可用于整个应用程序中。</p><p>组件知道如何渲染自己及配置依赖注入。</p><p>组件通过一些由属性和方法组成的 API 与视图交互。</p><p>创建 Angular 组件的方法有三步：</p><p>从 @angular/core 中引入 Component 修饰器</p><p>建立一个普通的类，并用 @Component 修饰它</p><p>在 @Component 中，设置 selector自定义标签，以及 template模板</p><h3 id="3-模板-Templates"><a href="#3-模板-Templates" class="headerlink" title="3.模板(Templates)"></a>3.模板(Templates)</h3><p>Angular模板的默认语言就是HTML。</p><p>我们可以通过使用模板来定义组件的视图来告诉 Angular 如何显示组件。以下是一个简单是实例：</p><p>网站地址 : [object Object]</p><h3 id="4-元数据-Metadata"><a href="#4-元数据-Metadata" class="headerlink" title="4.元数据(Metadata)"></a>4.元数据(Metadata)</h3><p>元数据告诉 Angular 如何处理一个类。</p><p>考虑以下情况我们有一个组件叫作 Component ，它是一个类，直到我们告诉 Angular 这是一个组件为止。</p><p>你可以把元数据附加到这个类上来告诉 Angular Component 是一个组件。</p><p>在 TypeScript 中，我们用 装饰器 (decorator) 来附加元数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">selector : <span class="string">'mylist'</span>,</span><br><span class="line"></span><br><span class="line">template : <span class="string">'菜鸟教程'</span></span><br><span class="line"></span><br><span class="line">directives : [ComponentDetails]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ListComponent</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>@Component 装饰器能接受一个配置对象，并把紧随其后的类标记成了组件类。</p><p>Angular 会基于这些信息创建和展示组件及其视图。</p><p>@Component 中的配置项说明：</p><p>selector- 一个 css 选择器，它告诉 Angular 在 父级 HTML 中寻找一个  标签，然后创建该组件，并插入此标签中。</p><p>templateUrl- 组件 HTML 模板的地址。</p><p>directives- 一个数组，包含 此 模板需要依赖的组件或指令。</p><p>providers- 一个数组，包含组件所依赖的服务所需要的依赖注入提供者。</p><h3 id="5-数据绑定-Data-binding"><a href="#5-数据绑定-Data-binding" class="headerlink" title="5.数据绑定(Data binding)"></a>5.数据绑定(Data binding)</h3><p>数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。</p><p>通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。</p><p>插值: 在 HTML 标签中显示组件值。</p>angular2组件之间的交互<p>属性绑定: 把元素的属性设置为组件中属性的值。</p><p>事件绑定: 在组件方法名被点击时触发。</p><p>双向绑: 使用Angular里的NgModel指令可以更便捷的进行双向绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(input)=<span class="string">"currentUser.firstName=$event.target.value"</span> &gt;</span><br></pre></td></tr></table></figure><h3 id="6-指令（Directives）"><a href="#6-指令（Directives）" class="headerlink" title="6.指令（Directives）"></a>6.指令（Directives）</h3><p>Angular模板是动态的 。当 Angular 渲染它们时，它会根据指令对 DOM 进行修改。</p><p>指令是一个带有”指令元数据”的类。在 TypeScript 中，要通过 @Directive 装饰器把元数据附加到类上。</p><p>在Angular中包含以下三种类型的指令：</p><p>属性指令：以元素的属性形式来使用的指令。</p><p>结构指令：用来改变DOM树的结构</p><p>组件：作为指令的一个重要子类，组件本质上可以看作是一个带有模板的指令。</p><p>*ngFor 告诉 Angular 为 sites 列表中的每个项生成一个</p><p>标签。</p><p>*ngIf 表示只有在选择的项存在时，才会包含 SiteDetail 组件。</p><h3 id="7-服务-Services"><a href="#7-服务-Services" class="headerlink" title="7.服务(Services)"></a>7.服务(Services)</h3><p>Angular2中的服务是封装了某一特定功能，并且可以通过注入的方式供他人使用的独立模块。</p><p>服务分为很多种，包括：值、函数，以及应用所需的特性。</p><p>例如，多个组件中出现了重复代码时，把重复代码提取到服务中实现代码复用。</p><p>以下是几种常见的服务：</p><p>日志服务</p><p>数据服务</p><p>消息总线</p><p>税款计算器</p><p>应用程序配置</p><p>以下实例是一个日志服务，用于把日志记录到浏览器的控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">log(msg: any) &#123; <span class="built_in">console</span>.log(msg); &#125;</span><br><span class="line"></span><br><span class="line">error(msg: any) &#123; <span class="built_in">console</span>.error(msg); &#125;</span><br><span class="line"></span><br><span class="line">warn(msg: any) &#123; <span class="built_in">console</span>.warn(msg); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-依赖注入"><a href="#8-依赖注入" class="headerlink" title="8.依赖注入"></a>8.依赖注入</h3><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫”依赖查找”（Dependency Lookup）。</p><p>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><p>在传统的开发模式中，调用者负责管理所有对象的依赖，循环依赖一直是梦魇，而在依赖注入模式中，这个管理权交给了注入器(Injector)，它在软件运行时负责依赖对象的替换，而不是在编译时。这种控制反转，运行注入的特点即是依赖注入的精华所在。</p><p>Angular 能通过查看构造函数的参数类型，来得知组件需要哪些服务。 例如， SiteListComponent 组件的构造函数需要一个 SiteService:</p><p>constructor(private service: HeroService) { }</p><p>当 Angular 创建组件时，会首先为组件所需的服务找一个注入器（ Injector ） 。</p><p>注入器是一个维护服务实例的容器，存放着以前创建的实例。</p><p>如果容器中还没有所请求的服务实例，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular 。</p><p>当所有的服务都被解析完并返回时， Angular 会以这些服务为参数去调用组件的构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通过输入型绑定把数据从父组件传到子组件。&quot;&gt;&lt;a href=&quot;#通过输入型绑定把数据从父组件传到子组件。&quot; class=&quot;headerlink&quot; title=&quot;通过输入型绑定把数据从父组件传到子组件。&quot;&gt;&lt;/a&gt;通过输入型绑定把数据从父组件传到子组件。&lt;/h2&gt;&lt;p&gt;HeroChildComponent 有两个输入型属性，它们通常带@Input 装饰器。&lt;br&gt;component-interaction/src/app/hero-child.component.ts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { Component, Input } from &amp;apos;@angular/core&amp;apos;;

import { Hero } from &amp;apos;./hero&amp;apos;;

@Component({
  selector: &amp;apos;app-hero-child&amp;apos;,
  template: `
    &amp;lt;h3&amp;gt;{{hero.name}} says:&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;I, {{hero.name}}, am at your service, {{masterName}}.&amp;lt;/p&amp;gt;
  `
})
export class HeroChildComponent {
  @Input() hero: Hero;
  @Input(&amp;apos;master&amp;apos;) masterName: string;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个 @Input 为子组件的属性名 masterName 指定一个别名 master(译者注：不推荐为起别名，请参见风格指南).&lt;/p&gt;
&lt;p&gt;父组件 HeroParentComponent 把子组件的 HeroChildComponent 放到 *ngFor 循环器中，把自己的 master 字符串属性绑定到子组件的 master 别名上，并把每个循环的 hero 实例绑定到子组件的 hero 属性。&lt;br&gt;component-interaction/src/app/hero-parent.component.ts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import { Component } from &amp;apos;@angular/core&amp;apos;;

import { HEROES } from &amp;apos;./hero&amp;apos;;

@Component({
  selector: &amp;apos;app-hero-parent&amp;apos;,
  template: `
    &amp;lt;h2&amp;gt;{{master}} controls {{heroes.length}} heroes&amp;lt;/h2&amp;gt;
    &amp;lt;app-hero-child *ngFor=&amp;quot;let hero of heroes&amp;quot;
      [hero]=&amp;quot;hero&amp;quot;
      [master]=&amp;quot;master&amp;quot;&amp;gt;
    &amp;lt;/app-hero-child&amp;gt;
  `
})
export class HeroParentComponent {
  heroes = HEROES;
  master = &amp;apos;Master&amp;apos;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="angular2" scheme="https://github.com/artdong/categories/angular2/"/>
    
    
      <category term="angular" scheme="https://github.com/artdong/tags/angular/"/>
    
      <category term="angular2" scheme="https://github.com/artdong/tags/angular2/"/>
    
  </entry>
  
  <entry>
    <title>tslint 与 git pre-commit 配置教程</title>
    <link href="https://github.com/artdong/2018/06/07/tslint%20git%20pre-commit%20%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://github.com/artdong/2018/06/07/tslint git pre-commit 配置教程/</id>
    <published>2018-06-07T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="tslint-配合pre-commit的意义"><a href="#tslint-配合pre-commit的意义" class="headerlink" title="tslint 配合pre-commit的意义"></a>tslint 配合pre-commit的意义</h2><p>为什么用pre-commit 加 tslint（jshint，eslint原理都类似），因为在项目中我们会经常忘记主动的去做代码检查，虽然结合webpack各种构建工具下，存在*slint报错，项目会跑不起来。但在某些情况下，可能会因为着急，或者其他原因，没有去观察项目运行的情况就仓促提交。团队开发的情景下，可能会成为别人的麻烦。而pre-commit tslint解决的需求既是：拒绝向仓库提交错误代码。</p><h2 id="git-hooks"><a href="#git-hooks" class="headerlink" title="git hooks"></a>git hooks</h2><p>在配置tslint pre commit之前，首先需要了解git hooks，正如它的名字所示，这是一个关于git 操作的钩子，比如我们想要在做远程仓库推送时，那就会触发pre-push这个钩子，然后在这个钩子中写下自己想做的事。git hooks的配置就在项目.git文件夹下面的hooks文件夹中。</p><p>在写相关的钩子函数时，需要注意的是，将钩子后面的sample后缀去掉，代码才会生效。</p><p>比如，本文中用到的pre-commit这个钩子。 </p><p>更多关于git hooks的介绍，请参考：<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a></p><p>下面介绍如何配置：</p><hr> <a id="more"></a><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ol><li>打开项目中的.git/hooks文件夹，找到pre-commit.sample文件，将以下代码替换到文件中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">TSLINT=&quot;$(git rev-parse --show-toplevel)/node_modules/.bin/tslint&quot;</span><br><span class="line">for file in $(git diff --cached --name-only | grep -E &apos;\.ts$&apos;)</span><br><span class="line">do</span><br><span class="line">        git show &quot;:$file&quot; | &quot;$TSLINT&quot; &quot;$file&quot;</span><br><span class="line">        if [ $? -ne 0 ]; then</span><br><span class="line">                exit 1</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol start="2"><li>将pre-commit.sample文件名修改为pre-commit。</li></ol><p>此时再打开项目运行git commit -m”xxx”命令时，tslint会做自动的检查，如果没有错误的话，才会提交成功。而存在tslint报错的话，会终止提交。<br><img src="https://upload-images.jianshu.io/upload_images/3100736-33f7c7ab5dc22071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tslint-error.png"></p><ul><li>注意： 日常开发中，有时为了方便会直接使用git commit -am”xxx”（即add+commit）的指令。而pre-commit 只是单独commit 钩子，因此还需要在pre-applypatch这个钩子下去做相同的配置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;tslint-配合pre-commit的意义&quot;&gt;&lt;a href=&quot;#tslint-配合pre-commit的意义&quot; class=&quot;headerlink&quot; title=&quot;tslint 配合pre-commit的意义&quot;&gt;&lt;/a&gt;tslint 配合pre-commit的意义&lt;/h2&gt;&lt;p&gt;为什么用pre-commit 加 tslint（jshint，eslint原理都类似），因为在项目中我们会经常忘记主动的去做代码检查，虽然结合webpack各种构建工具下，存在*slint报错，项目会跑不起来。但在某些情况下，可能会因为着急，或者其他原因，没有去观察项目运行的情况就仓促提交。团队开发的情景下，可能会成为别人的麻烦。而pre-commit tslint解决的需求既是：拒绝向仓库提交错误代码。&lt;/p&gt;
&lt;h2 id=&quot;git-hooks&quot;&gt;&lt;a href=&quot;#git-hooks&quot; class=&quot;headerlink&quot; title=&quot;git hooks&quot;&gt;&lt;/a&gt;git hooks&lt;/h2&gt;&lt;p&gt;在配置tslint pre commit之前，首先需要了解git hooks，正如它的名字所示，这是一个关于git 操作的钩子，比如我们想要在做远程仓库推送时，那就会触发pre-push这个钩子，然后在这个钩子中写下自己想做的事。git hooks的配置就在项目.git文件夹下面的hooks文件夹中。&lt;/p&gt;
&lt;p&gt;在写相关的钩子函数时，需要注意的是，将钩子后面的sample后缀去掉，代码才会生效。&lt;/p&gt;
&lt;p&gt;比如，本文中用到的pre-commit这个钩子。 &lt;/p&gt;
&lt;p&gt;更多关于git hooks的介绍，请参考：&lt;a href=&quot;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面介绍如何配置：&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="tslint" scheme="https://github.com/artdong/categories/tslint/"/>
    
    
      <category term="tslint" scheme="https://github.com/artdong/tags/tslint/"/>
    
      <category term="git" scheme="https://github.com/artdong/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TSLint常用配置及使用方法</title>
    <link href="https://github.com/artdong/2018/06/06/TSLint/"/>
    <id>https://github.com/artdong/2018/06/06/TSLint/</id>
    <published>2018-06-06T05:55:55.000Z</published>
    <updated>2019-07-23T06:04:42.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="TSLint核心规则及相关库"><a href="#TSLint核心规则及相关库" class="headerlink" title="TSLint核心规则及相关库"></a>TSLint核心规则及相关库</h2><p>TSLint已经提供了一些核心规则，但是还不够，于是有人用TSLint提供的自定义接口又自定义了许多规则。如：</p><ul><li>tslint-eslint-rules——ionic项目默认使用这个</li><li>codelyzer——angular项目默认使用这个</li><li><p>还有很多</p><hr></li></ul>  <a id="more"></a><h2 id="腾讯团队开源项目tslint-config-alloy"><a href="#腾讯团队开源项目tslint-config-alloy" class="headerlink" title="腾讯团队开源项目tslint-config-alloy"></a>腾讯团队开源项目tslint-config-alloy</h2><p>现在有了大量校验规则，如何使用如何配置呢。我们使用了腾讯团队的开源项目tslint-config-alloy，它的配置原则：</p><ul><li>能够帮助发现代码错误的规则，全部开启</li><li>配置不应该依赖于某个具体项目，而应尽可能的合理</li><li>帮助保持团队的代码风格统一，而不是限制开发体验</li></ul><p>如果觉得tslint-config-alloy提供的配置不合理，我们就可以在本文最开始提到的tslint.json文件(ionic项目根目录下)中覆盖它的配置</p><h2 id="如何使用tslint-config-alloy"><a href="#如何使用tslint-config-alloy" class="headerlink" title="如何使用tslint-config-alloy"></a>如何使用tslint-config-alloy</h2><ul><li><p>项目安装依赖：npm install –save-dev tslint-eslint-rules tslint-config-alloy</p><p> 其中tslint-eslint-rules是规则的实现，它的规则已经继承了tslint，其中tslint-config-alloy是规则的配置，我们的配置继承这里的配置。</p></li><li><p>配置tslint.json内容如下</p><p>其中rulesDirectory指定规则的实现目录，可以配置多个，如你自定义的规则的目录；其中extends指定我们继承的配置，这里继承tslint-config-alloy，我们可以在rules中添加配置和覆盖tslint-config-alloy提供的配置。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"tslint-config-alloy"</span>,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    "no-parameter-properties":false, // 禁止给类的构造函数的参数添加修饰符</span><br><span class="line">    "triple-equals":false,</span><br><span class="line">    "no-debugger": false,</span><br><span class="line">    // 禁止行尾有空格</span><br><span class="line">    "no-trailing-whitespace": false,</span><br><span class="line">    "member-ordering":false,</span><br><span class="line">    "no-this-assignment": [true, &#123;"allowed-names": ["^self$","^that$"], "allow-destructuring": true&#125;],</span><br><span class="line">    // 必须使用箭头函数，除非是单独的函数声明或是命名函数</span><br><span class="line">    "only-arrow-functions": [</span><br><span class="line">      false,</span><br><span class="line">      "allow-declarations",</span><br><span class="line">      <span class="string">"allow-named-functions"</span></span><br><span class="line">    ],</span><br><span class="line">    // 禁止出现空代码块，允许 catch 是空代码块</span><br><span class="line">    "no-empty": [</span><br><span class="line">      false,</span><br><span class="line">      <span class="string">"allow-empty-catch"</span></span><br><span class="line">    ],</span><br><span class="line">    // 禁止无用的类型断言</span><br><span class="line">    "no-unnecessary-type-assertion": false,</span><br><span class="line">    // 使用 return; 而不是 return undefined;</span><br><span class="line">    "return-undefined": false,</span><br><span class="line">    // 禁止对 array 使用 for in 循环</span><br><span class="line">    "no-for-in-array": false,</span><br><span class="line">    "comment-format": [true, "check-space"], // 单行注释格式化规则</span><br><span class="line">  &#125;,</span><br><span class="line">  "rulesDirectory": [</span><br><span class="line">    <span class="string">"node_modules/tslint-eslint-rules/dist/rules"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tslint代码风格规则和ide默认的格式化代码风格存在冲突如何解决"><a href="#tslint代码风格规则和ide默认的格式化代码风格存在冲突如何解决" class="headerlink" title="tslint代码风格规则和ide默认的格式化代码风格存在冲突如何解决"></a>tslint代码风格规则和ide默认的格式化代码风格存在冲突如何解决</h2><p>   这时候要么在tslint.json重新定义规则，要么修改ide配置，如：</p><ol><li><p>webstorm设置import自动导入的内容为单引号<br><img src="https://upload-images.jianshu.io/upload_images/3100736-ae0ab7129b2d7469.gif?imageMogr2/auto-orient/strip" alt="webstorm-punctation.gif"></p></li><li><p>webstorm设置import自动导入大括号两边添加空格<br><img src="https://upload-images.jianshu.io/upload_images/3100736-aad1e6a8a61076d7.gif?imageMogr2/auto-orient/strip" alt="webstorm-spaces.gif"></p><p>默认自动生成格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;AbstractControl&#125; from &apos;@angular/forms&apos;;</span><br></pre></td></tr></table></figure><p>想要格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AbstractControl &#125; from &apos;@angular/forms&apos;;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>其他配置自行百度</li><li>实际开发过程中可以先不启用TSLint，每次提交代码前或测试开发的代码时在启用并修复问题</li></ol><h2 id="TSLint注释标记"><a href="#TSLint注释标记" class="headerlink" title="TSLint注释标记"></a>TSLint注释标记</h2><ul><li><p>ts文件中使用以下注释来临时忽略规则出现的错误，参考这里</p><p>  /<em> tslint:disable </em>/——忽略该行以下所有代码出现的错误提示</p><p>  /<em> tslint:enable </em>/——当前ts文件重新启用tslint</p><p>  // tslint:disable-line——忽略当前行代码出现的错误提示</p><p>  // tslint:disable-next-line——忽略下一行代码出现的错误提示</p></li></ul><h2 id="常用的tslint配置项"><a href="#常用的tslint配置项" class="headerlink" title="常用的tslint配置项"></a>常用的tslint配置项</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 禁止给类的构造函数的参数添加修饰符</span><br><span class="line">  "no-parameter-properties": false,</span><br><span class="line">  // 禁止使用 debugger</span><br><span class="line">  "no-debugger": false,</span><br><span class="line">  // 禁止行尾有空格</span><br><span class="line">  "no-trailing-whitespace": false,</span><br><span class="line">  // 禁止无用的表达式</span><br><span class="line">  "no-unused-expression": true,</span><br><span class="line">  // 定义过的变量必须使用</span><br><span class="line">  "no-unused-variable": true,</span><br><span class="line">  // 变量必须先定义后使用</span><br><span class="line">  "no-use-before-declare": true,</span><br><span class="line">  // 禁止使用 var</span><br><span class="line">  "no-var-keyword": true,</span><br><span class="line">  // 必须使用 === 或 !==，禁止使用 == 或 !=，与 null 比较时除外</span><br><span class="line">  "triple-equals": true,</span><br><span class="line">  // 指定类成员的排序规则</span><br><span class="line">  "member-ordering": false,</span><br><span class="line">  // 禁止将 this 赋值给其他变量，除非是解构赋值</span><br><span class="line">  "no-this-assignment": [</span><br><span class="line">    false,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"allowed-names"</span>: [</span><br><span class="line">        <span class="string">"^self$"</span>,</span><br><span class="line">        <span class="string">"^that$"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"allow-destructuring"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // 必须使用箭头函数，除非是单独的函数声明或是命名函数</span><br><span class="line">  "only-arrow-functions": [</span><br><span class="line">    true,</span><br><span class="line">    "allow-declarations",</span><br><span class="line">    <span class="string">"allow-named-functions"</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止出现空代码块，允许 catch 是空代码块</span><br><span class="line">  "no-empty": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"allow-empty-catch"</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止无用的类型断言</span><br><span class="line">  "no-unnecessary-type-assertion": true,</span><br><span class="line">  // 使用 return; 而不是 return undefined;</span><br><span class="line">  "return-undefined": true,</span><br><span class="line">  // 禁止对 array 使用 for in 循环</span><br><span class="line">  "no-for-in-array": true,</span><br><span class="line">  "comment-format": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"check-space"</span></span><br><span class="line">  ],</span><br><span class="line">  // 单行注释格式化规则</span><br><span class="line">  // 定义函数时如果用到了覆写，则必须将覆写的函数写到一起</span><br><span class="line">  "adjacent-overload-signatures": true,</span><br><span class="line">  // 禁止对函数的参数重新赋值</span><br><span class="line">  "no-parameter-reassignment": true,</span><br><span class="line">  // if 后面必须有 &#123;，除非是单行 if</span><br><span class="line">  "curly": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"ignore-same-line"</span></span><br><span class="line">  ],</span><br><span class="line">  // for in 内部必须有 hasOwnProperty</span><br><span class="line">  "forin": true,</span><br><span class="line">  // 禁止在分支条件判断中有赋值操作</span><br><span class="line">  "no-conditional-assignment": true,</span><br><span class="line">  // 禁止使用 new 来生成 String, Number 或 Boolean</span><br><span class="line">  "no-construct": true,</span><br><span class="line">  // 禁止 super 在一个构造函数中出现两次</span><br><span class="line">  "no-duplicate-super": true,</span><br><span class="line">  // 禁止在 switch 语句中出现重复测试表达式的 case</span><br><span class="line">  "no-duplicate-switch-case": true,</span><br><span class="line">  // 禁止出现重复的变量定义或函数参数名</span><br><span class="line">  "no-duplicate-variable": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"check-parameters"</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止使用 eval</span><br><span class="line">  "no-eval": true,</span><br><span class="line">  // 禁止对对象字面量进行类型断言（断言成 any 是允许的）</span><br><span class="line">  "no-object-literal-type-assertion": true,</span><br><span class="line">  // 禁止没必要的 return await</span><br><span class="line">  "no-return-await": true,</span><br><span class="line">  // 禁止在数组中出现连续的逗号，如 let foo = [,,]</span><br><span class="line">  "no-sparse-arrays": true,</span><br><span class="line">  // 禁止 throw 字符串，必须 throw 一个 Error 对象</span><br><span class="line">  "no-string-throw": true,</span><br><span class="line">  // switch 的 case 必须 return 或 break</span><br><span class="line">  "no-switch-case-fall-through": true,</span><br><span class="line">  // 使用实例的方法时，必须 bind 到实例上</span><br><span class="line">  "no-unbound-method": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"ignore-static"</span></span><br><span class="line">  ],</span><br><span class="line">  // 使用 &#123; ...foo, bar: 1 &#125; 代替 Object.assign(&#123;&#125;, foo, &#123; bar: 1 &#125;)</span><br><span class="line">  // 前者的类型检查更完善</span><br><span class="line">  "prefer-object-spread": true,</span><br><span class="line">  // parseInt 必须传入第二个参数</span><br><span class="line">  "radix": true,</span><br><span class="line">  // 必须使用 isNaN(foo) 而不是 foo === NaN</span><br><span class="line">  "use-isnan": true,</span><br><span class="line">  //</span><br><span class="line">  //</span><br><span class="line">  // 可维护性</span><br><span class="line">  // 这些规则可以增加代码的可维护性</span><br><span class="line">  //</span><br><span class="line">  // 禁止函数的循环复杂度超过 20，https://en.wikipedia.org/wiki/Cyclomatic_complexity</span><br><span class="line">  "cyclomatic-complexity": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止使用废弃（被标识了 @deprecated）的 API</span><br><span class="line">  "deprecation": true,</span><br><span class="line">  // 一个缩进必须用四个空格替代</span><br><span class="line">  "indent": [</span><br><span class="line">    true,</span><br><span class="line">    "spaces",</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止出现重复的 import</span><br><span class="line">  "no-duplicate-imports": true,</span><br><span class="line">  // 禁止一个文件中出现多个相同的 namespace</span><br><span class="line">  "no-mergeable-namespace": true,</span><br><span class="line">  // 文件类型必须时 utf-8</span><br><span class="line">  "encoding": true,</span><br><span class="line">  // import 语句中，关键字之间的间距必须是一个空格</span><br><span class="line">  "import-spacing": true,</span><br><span class="line">  // 接口可以 implement extend 和 merge</span><br><span class="line">  "interface-over-type-literal": true,</span><br><span class="line">  // new 后面只必须有一个空格</span><br><span class="line">  "new-parens": true,</span><br><span class="line">  // 类型断言必须使用 as Type，禁止使用 &lt;Type&gt;</span><br><span class="line">  // &lt;Type&gt; 容易被理解为 jsx</span><br><span class="line">  "no-angle-bracket-type-assertion": true,</span><br><span class="line">  // 禁止连续超过三行空行</span><br><span class="line">  "no-consecutive-blank-lines": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止使用特殊空白符（比如全角空格）</span><br><span class="line">  "no-irregular-whitespace": true,</span><br><span class="line">  // 禁止使用 JSDoc，因为 TypeScirpt 已经包含了大部分功能</span><br><span class="line">  "no-redundant-jsdoc": true,</span><br><span class="line">  // 禁止使用三斜杠引入类型定义文件</span><br><span class="line">  "no-reference-import": true,</span><br><span class="line">  // 禁止变量定义时赋值为 undefined</span><br><span class="line">  "no-unnecessary-initializer": true,</span><br><span class="line">  // 小数必须以 0. 开头，禁止以 . 开头，并且不能以 0 结尾</span><br><span class="line">  "number-literal-format": true,</span><br><span class="line">  // 必须使用 a = &#123;b&#125; 而不是 a = &#123;b: b&#125;</span><br><span class="line">  "object-literal-shorthand": true,</span><br><span class="line">  // 变量申明必须每行一个，for 循环的初始条件中除外</span><br><span class="line">  "one-variable-per-declaration": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"ignore-for-loop"</span></span><br><span class="line">  ],</span><br><span class="line">  // if 后的 &#123; 禁止换行</span><br><span class="line">  "one-line": true,</span><br><span class="line">  // 必须使用单引号，jsx 中必须使用双引号</span><br><span class="line">  "quotemark": [</span><br><span class="line">    true,</span><br><span class="line">    "single",</span><br><span class="line">    "jsx-double",</span><br><span class="line">    "avoid-template",</span><br><span class="line">    <span class="string">"avoid-escape"</span></span><br><span class="line">  ],</span><br><span class="line">  // 行尾必须有分号</span><br><span class="line">  "semicolon": [</span><br><span class="line">    true,</span><br><span class="line">    "always",</span><br><span class="line">    <span class="string">"ignore-interfaces"</span></span><br><span class="line">  ],</span><br><span class="line">  // 函数名前必须有空格</span><br><span class="line">  "space-before-function-paren": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="string">"asyncArrow"</span></span><br><span class="line">  ],</span><br><span class="line">  // 括号内首尾禁止有空格</span><br><span class="line">  "space-within-parens": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  ],</span><br><span class="line">  // 禁止 finally 内出现 return, continue, break, throw 等</span><br><span class="line">  // finally 会比 catch 先执行</span><br><span class="line">  "no-unsafe-finally": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TSLint核心规则及相关库&quot;&gt;&lt;a href=&quot;#TSLint核心规则及相关库&quot; class=&quot;headerlink&quot; title=&quot;TSLint核心规则及相关库&quot;&gt;&lt;/a&gt;TSLint核心规则及相关库&lt;/h2&gt;&lt;p&gt;TSLint已经提供了一些核心规则，但是还不够，于是有人用TSLint提供的自定义接口又自定义了许多规则。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tslint-eslint-rules——ionic项目默认使用这个&lt;/li&gt;
&lt;li&gt;codelyzer——angular项目默认使用这个&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还有很多&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tslint" scheme="https://github.com/artdong/categories/tslint/"/>
    
    
      <category term="tslint" scheme="https://github.com/artdong/tags/tslint/"/>
    
  </entry>
  
  <entry>
    <title>深入理解普通函数中的this及ES6箭头函数的this</title>
    <link href="https://github.com/artdong/2018/06/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84this/"/>
    <id>https://github.com/artdong/2018/06/06/深入理解js中的this/</id>
    <published>2018-06-06T03:11:11.000Z</published>
    <updated>2019-07-23T06:04:42.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this:"></a>普通函数中的this:</h2><ol><li><p>this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj</p></li><li><p>在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)</p></li><li><p>在严格模式下,没有直接调用者的函数中的this是 undefined</p></li><li><p>使用call,apply,bind(ES5新增)绑定的,this指的是绑定的对象</p></li></ol><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this</p><p>下面通过一些例子来研究一下 this的一些使用场景</p><hr> <a id="more"></a><h2 id="首先了解一下作用域链"><a href="#首先了解一下作用域链" class="headerlink" title="首先了解一下作用域链:"></a>首先了解一下作用域链:</h2><p>当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数,</p><p>最后直到window,全局变量默认挂载在window对象下</p><ol><li><p>全局变量默认挂载在window对象下</p></li><li><p>在普通函数中,this指向它的直接调用者;如果找不到直接调用者,则是window</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  test();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>结果是: window </p><p>原因: test()是一个全局函数,也就是说是挂在window对象下的,所以test()等价于 window.test() ,所以此时的this是window</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   obj.say();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>结果是: window</p><p>匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window</p><p>3.在严格模式下的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">test();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>结果是: undefined</p><p>4.箭头函数中的 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say(); <span class="comment">// obj</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window!</p><p>示例(多层嵌套的箭头函数):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// obj</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// obj</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    f1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>因为f1定义时所处的函数 中的 this是指的 obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj</p><p>示例(复杂情况: 普通函数和箭头函数混杂嵌套)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window, f1调用时,没有宿主对象,默认是window</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    f1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>结果: 都是 window,因为 箭头函数在定义的时候它所处的环境相当于是window, 所以在箭头函数内部的this函数window</p><p>示例(严格模式下的混杂嵌套)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    f1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>结果都是undefined</p><p>说明: 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined!</p><ul><li>总结:</li></ul><p>使用箭头函数,可以让我们解决一些在匿名函数中this指向不正确的问题; 但是要注意在和普通函数混合的时候,this的指向可能是window !</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;普通函数中的this&quot;&gt;&lt;a href=&quot;#普通函数中的this&quot; class=&quot;headerlink&quot; title=&quot;普通函数中的this:&quot;&gt;&lt;/a&gt;普通函数中的this:&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在严格模式下,没有直接调用者的函数中的this是 undefined&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用call,apply,bind(ES5新增)绑定的,this指的是绑定的对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;箭头函数中的this&quot;&gt;&lt;a href=&quot;#箭头函数中的this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数中的this&quot;&gt;&lt;/a&gt;箭头函数中的this&lt;/h2&gt;&lt;p&gt;箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this&lt;/p&gt;
&lt;p&gt;下面通过一些例子来研究一下 this的一些使用场景&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="js" scheme="https://github.com/artdong/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/artdong/tags/js/"/>
    
      <category term="this" scheme="https://github.com/artdong/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>ionic3之tabs用法详解,你知道的和不知道的都在这儿</title>
    <link href="https://github.com/artdong/2018/06/06/ionic3_tabs/"/>
    <id>https://github.com/artdong/2018/06/06/ionic3_tabs/</id>
    <published>2018-06-06T02:30:00.000Z</published>
    <updated>2019-07-23T06:04:42.544Z</updated>
    
    <content type="html"><![CDATA[Tabs（选项卡）ion-tabs在一个 app 中，Tabs 使得在不同页面和功能之间导航更加容易。Tabs 组件，以 <ion-tabs> 的方式写，是单个 Tab 组件的容器。每个 <ion-tab> 对于 NavControll 来说是公开的组件。那么tabs有哪些属性和事件呢？下面详细介绍一下: <a id="more"></a> <h3> 属性和事件详解 </h3><table>  <tr>     <th>标签</th>     <th>类型</th>     <th>作用</th>   </tr>  <tr>     <td>[root]</td>     <td>Page</td>     <td>指定tab希望加载的页面</td>   </tr>   <tr>     <td>tabTitle</td>     <td>string</td>     <td>tab上显示的标题</td>   </tr>   <tr>     <td>tabIcon</td>     <td>string</td>     <td>tab上显示的图标</td>   </tr>   <tr>     <td>tabBadge</td>     <td>string</td>     <td>tab上显示的角标数字</td>   </tr>   <tr>     <td>tabBadgeStyle</td>     <td>string</td>     <td>角标数字的颜色</td>   </tr> <tr>    <td>enabled</td>    <td>boolean</td>    <td>tab是否可用，默认为true</td>  </tr>  <tr>    <td>show</td>    <td>boolean</td>    <td>tab是否显示</td>  </tr>  <tr>    <td>[rootParams]</td>    <td>object</td>    <td>tab上传递的参数</td>  </tr>   <tr>    <td>tabUrlPath</td>    <td>string</td>    <td>点击tab时跳转的页面url</td>  </tr>   <tr>    <td>swipeBackEnabled</td>    <td>boolean</td>    <td>是否支持滑动后退</td>  </tr>   <tr>    <td>tabsHideOnSubPages</td>    <td>boolean</td>    <td>在子页面是否隐藏</td>  </tr>   <tr>    <td>(ionSelect)</td>    <td>方法</td>    <td>tab select 方法</td>  </tr>  </table>* 示例html代码如下:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ion-tabs</span> #<span class="attr">mainTabs</span> (<span class="attr">ionChange</span>)=<span class="string">"changeTabs()"</span> <span class="attr">color</span>=<span class="string">"danger"</span> <span class="attr">tabsHighlight</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-tab</span> [<span class="attr">root</span>]=<span class="string">"tab1Root"</span> [<span class="attr">rootParams</span>]=<span class="string">"homeParams"</span> <span class="attr">tabTitle</span>=<span class="string">"Home"</span> <span class="attr">tabIcon</span>=<span class="string">"home"</span>&gt;</span><span class="tag">&lt;/<span class="name">ion-tab</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-tab</span> [<span class="attr">root</span>]=<span class="string">"tab2Root"</span> (<span class="attr">ionSelect</span>)=<span class="string">"selectFriend()"</span> <span class="attr">tabTitle</span>=<span class="string">"Friends"</span> <span class="attr">tabIcon</span>=<span class="string">"aperture"</span> <span class="attr">tabBadge</span>=<span class="string">"3"</span> <span class="attr">tabBadgeStyle</span>=<span class="string">"danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">ion-tab</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ion-tab</span> [<span class="attr">root</span>]=<span class="string">"tab3Root"</span> <span class="attr">enabled</span>=<span class="string">"false"</span>  <span class="attr">swipeBackEnabled</span>=<span class="string">"true"</span> <span class="attr">tabTitle</span>=<span class="string">"Contact"</span> <span class="attr">tabIcon</span>=<span class="string">"contacts"</span>&gt;</span><span class="tag">&lt;/<span class="name">ion-tab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ion-tabs</span>&gt;</span></span><br></pre></td></tr></table></figure>* 示例typeScript脚本代码如下：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, ViewChild &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HomePage &#125; <span class="keyword">from</span> <span class="string">'../home/home'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AboutPage &#125; <span class="keyword">from</span> <span class="string">'../about/about'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ContactPage &#125; <span class="keyword">from</span> <span class="string">'../contact/contact'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Tabs, ModalController &#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;templateUrl: <span class="string">'tabs.html'</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TabsPage &#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">'mainTabs'</span>) tabRef: Tabs;</span><br><span class="line">  <span class="comment">// this tells the tabs component which Pages</span></span><br><span class="line">  <span class="comment">// should be each tab's root Page</span></span><br><span class="line">  <span class="comment">// 为tab标签指定导航至的页面</span></span><br><span class="line">  tab1Root: <span class="built_in">any</span> = HomePage;</span><br><span class="line">  tab2Root: <span class="built_in">any</span> = AboutPage;</span><br><span class="line">  tab3Root: <span class="built_in">any</span> = ContactPage;</span><br><span class="line">  <span class="comment">// 指定参数,在tab指向的页面可以读取到该参数</span></span><br><span class="line">  homeParams: <span class="built_in">any</span> = &#123;user1: <span class="string">'admin'</span>, user2: <span class="string">'ionic'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> modalCtrl: ModalController</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  changeTabs = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tab changed'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 选中tab页后的事件</span></span><br><span class="line">  selectFriend() &#123;</span><br><span class="line">    <span class="keyword">let</span> modal = <span class="keyword">this</span>.modalCtrl.create(ContactPage); <span class="comment">// 声明一个modal</span></span><br><span class="line">    modal.present(); <span class="comment">// 弹出modal</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ionViewDidEnter() &#123;</span><br><span class="line">    <span class="keyword">let</span> mainTabs = <span class="keyword">this</span>.tabRef;</span><br><span class="line">    mainTabs.select(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>* home页使用参数示例代码如下：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="comment">// 引入NavParams</span></span><br><span class="line"><span class="keyword">import</span> &#123; NavController,NavParams &#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'page-home'</span>,</span><br><span class="line">    templateUrl: <span class="string">'home.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomePage &#123;</span><br><span class="line">    <span class="comment">// 在这里指定navParams</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> navCtrl: NavController,<span class="keyword">public</span> navParams:NavParams</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ionViewWillEnter()&#123;</span><br><span class="line">        <span class="comment">// 使用this.navParams.data可以读取tab页传过来的参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"NavParams:"</span>+<span class="keyword">this</span>.navParams.data.user1);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"NavParams:"</span>+<span class="keyword">this</span>.navParams.data.user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></ion-tab></ion-tabs>]]></content>
    
    <summary type="html">
    
      Tabs（选项卡）
ion-tabs

在一个 app 中，Tabs 使得在不同页面和功能之间导航更加容易。Tabs 组件，以 &lt;ion-tabs&gt; 的方式写，是单个 Tab 组件的容器。每个 &lt;ion-tab&gt; 对于 NavControll 来说是公开的组件。

那么tabs有哪些属性和事件呢？下面详细介绍一下:
    
    </summary>
    
      <category term="ionic3" scheme="https://github.com/artdong/categories/ionic3/"/>
    
    
      <category term="ionic" scheme="https://github.com/artdong/tags/ionic/"/>
    
      <category term="ionic3" scheme="https://github.com/artdong/tags/ionic3/"/>
    
  </entry>
  
  <entry>
    <title>ionic3中的gestures 手势事件归档</title>
    <link href="https://github.com/artdong/2018/06/02/ionic3-guestures/"/>
    <id>https://github.com/artdong/2018/06/02/ionic3-guestures/</id>
    <published>2018-06-02T03:11:11.000Z</published>
    <updated>2019-07-23T06:04:42.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ionic3中的gestures-手势事件如下："><a href="#ionic3中的gestures-手势事件如下：" class="headerlink" title="ionic3中的gestures 手势事件如下："></a>ionic3中的gestures 手势事件如下：</h3><p>ionic3中的gestures 手势事件包括: tap,  press,  pan,  swipe, rotate,  pinch 等事件，</p><p>tap    点击事件</p><p>press   长按事件</p><p>pan    滑动的时候触发的事件,滑动触发多次</p><p>swipe 滑动事件 滑动触发一次</p><p>rotate 旋转事件</p><p>pinch  捏合(pinch)手势</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ionic3中的gestures-手势事件如下：&quot;&gt;&lt;a href=&quot;#ionic3中的gestures-手势事件如下：&quot; class=&quot;headerlink&quot; title=&quot;ionic3中的gestures 手势事件如下：&quot;&gt;&lt;/a&gt;ionic3中的gestur
      
    
    </summary>
    
      <category term="ionic3" scheme="https://github.com/artdong/categories/ionic3/"/>
    
    
      <category term="ionic" scheme="https://github.com/artdong/tags/ionic/"/>
    
      <category term="ionic3" scheme="https://github.com/artdong/tags/ionic3/"/>
    
  </entry>
  
  <entry>
    <title>ionic3-awesome</title>
    <link href="https://github.com/artdong/2018/06/01/ionic3-awesome/"/>
    <id>https://github.com/artdong/2018/06/01/ionic3-awesome/</id>
    <published>2018-06-01T03:11:11.000Z</published>
    <updated>2019-07-23T06:04:42.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><hr></blockquote><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>:smiley: ionic3自定义组件及常用例子演示地址。欢迎贡献代码。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>ionic3 + cordova</p><h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/artdong/ionic3-awesome</span><br><span class="line"></span><br><span class="line">cd ionic3-awesome </span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">ionic serve (运行开发模式)</span><br><span class="line"></span><br><span class="line">浏览器打开: http://localhost:8080</span><br><span class="line"></span><br><span class="line">ionic cordova run build android (安卓打包发布)</span><br><span class="line"></span><br><span class="line">ionic cordova run build ios (安卓打包发布)</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h3 id="app演示"><a href="#app演示" class="headerlink" title="app演示"></a>app演示</h3><aside id="platform-preview" class="platform-preview"><br>    <div id="demo-device-android" ng-class="previewPlatform" ng-show="androidActive" class="android" style><br>            <iframe id="demo-android" src="https://artdong.github.io/ionic3-awesome/#/index" frameborder="0"><br>            </iframe><br>        </div><br></aside><iframe frameborder="0" scrolling="0" width="90px" height="22px" src="https://ghbtns.com/github-btn.html?user=artdong&amp;repo=ionic3-awesome&amp;type=star&amp;count=true"> </iframe>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;About&quot;&gt;&lt;a href=&quot;#About&quot; class=&quot;headerlink&quot; title=&quot;About&quot;&gt;&lt;/a&gt;About&lt;/h2&gt;&lt;p&gt;:smiley: ionic3自定义组件及常用例子演示地址。欢迎贡献代码。&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title=&quot;技术栈&quot;&gt;&lt;/a&gt;技术栈&lt;/h2&gt;&lt;p&gt;ionic3 + cordova&lt;/p&gt;
&lt;h2 id=&quot;项目运行&quot;&gt;&lt;a href=&quot;#项目运行&quot; class=&quot;headerlink&quot; title=&quot;项目运行&quot;&gt;&lt;/a&gt;项目运行&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/artdong/ionic3-awesome&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ionic3-awesome &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ionic serve (运行开发模式)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;浏览器打开: http://localhost:8080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ionic cordova run build android (安卓打包发布)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ionic cordova run build ios (安卓打包发布)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="ionic3" scheme="https://github.com/artdong/categories/ionic3/"/>
    
    
      <category term="ionic" scheme="https://github.com/artdong/tags/ionic/"/>
    
      <category term="ionic3" scheme="https://github.com/artdong/tags/ionic3/"/>
    
  </entry>
  
  <entry>
    <title>ionic-for100</title>
    <link href="https://github.com/artdong/2018/05/31/ionic-for100/"/>
    <id>https://github.com/artdong/2018/05/31/ionic-for100/</id>
    <published>2018-05-31T13:52:25.000Z</published>
    <updated>2019-07-23T06:04:42.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><strong><em>一个基于<code>ionic</code>的小应用-挑战100。</em></strong></p></blockquote><a id="more"></a><h3 id="app演示"><a href="#app演示" class="headerlink" title="app演示"></a>app演示</h3><p><aside id="platform-preview" class="platform-preview"><br>    <div id="demo-device-android" ng-class="previewPlatform" ng-show="androidActive" class="android" style><br>            <iframe id="demo-android" src="https://artdong.github.io/ionic-for100/#/index" frameborder="0"><br>            </iframe><br>        </div><br></aside><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;一个基于&lt;code&gt;ionic&lt;/code&gt;的小应用-挑战100。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="ionic" scheme="https://github.com/artdong/categories/ionic/"/>
    
    
      <category term="ionic" scheme="https://github.com/artdong/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>两种方法轻松搞定NodeJS实时编译，动态调试</title>
    <link href="https://github.com/artdong/2017/03/06/nodejs%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>https://github.com/artdong/2017/03/06/nodejs实时编译和动态调试/</id>
    <published>2017-03-06T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="Node-js开发中遇到这样的问题"><a href="#Node-js开发中遇到这样的问题" class="headerlink" title="Node.js开发中遇到这样的问题"></a>Node.js开发中遇到这样的问题</h2><p>总是重新读取并解析脚本(如果没有专门的优化配置)。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。</p><p>这时若你修改了js文件，或是调试功能，或是增加功能。这时需要重新发布该服务，每次修改都需要执行以下两步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">control+c</span><br><span class="line">node server.js</span><br></pre></td></tr></table></figure><p>很不爽有木有！因此有人开发了一个自动发布（热发布）的工具，你只需要在修改文件后保存，它就能自动替你发布，这就是所谓的热部署。就像tomcat或websphere等一些主流的web应用服务器那样保存即热部署。下面将介绍两个NodeJS中的开源热部署工具。</p><hr>  <a id="more"></a><h2 id="1-supervisor"><a href="#1-supervisor" class="headerlink" title="(1)supervisor"></a>(1)supervisor</h2><p>supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装 supervisor：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g supervisor</span><br></pre></td></tr></table></figure><p>如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -g supervisor 命令来安装。</p><p>接下来，使用 supervisor 命令启动 app.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ supervisor app.js</span><br></pre></td></tr></table></figure><p>命令行窗口会显示启动成功信息，即开启了代码监听。</p><p>当代码被改动时，运行的脚本会被终止，然后重新启动。</p><p>supervisor 这个小工具可以解决开发中的调试问题。</p><p>github地址：<a href="https://github.com/isaacs/node-supervisor">https://github.com/isaacs/node-supervisor</a></p><h2 id="2-hotnode"><a href="#2-hotnode" class="headerlink" title="(2)hotnode"></a>(2)hotnode</h2><p>首先需要安装，打开NodeJS命令行工具，输入sudo npm -g install hotcode进行全局安装</p><p>安装成功后，可以随时查看它的版本号，在命令行输入：hotcode -v</p><p>使用很简单，执行命令:hotcode server.js。</p><p>每次修改都会有一条日志打印出来。</p><p>github地址：<a href="https://github.com/saschagehlich/hotnode">https://github.com/saschagehlich/hotnode</a></p><h2 id="nodejs-express入门示例"><a href="#nodejs-express入门示例" class="headerlink" title="nodejs + express入门示例"></a>nodejs + express入门示例</h2><p>nodejs + express入门示例： <a href="https://github.com/artdong/node-server">https://github.com/artdong/node-server</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Node-js开发中遇到这样的问题&quot;&gt;&lt;a href=&quot;#Node-js开发中遇到这样的问题&quot; class=&quot;headerlink&quot; title=&quot;Node.js开发中遇到这样的问题&quot;&gt;&lt;/a&gt;Node.js开发中遇到这样的问题&lt;/h2&gt;&lt;p&gt;总是重新读取并解析脚本(如果没有专门的优化配置)。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。&lt;/p&gt;
&lt;p&gt;这时若你修改了js文件，或是调试功能，或是增加功能。这时需要重新发布该服务，每次修改都需要执行以下两步：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;control+c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;node server.js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很不爽有木有！因此有人开发了一个自动发布（热发布）的工具，你只需要在修改文件后保存，它就能自动替你发布，这就是所谓的热部署。就像tomcat或websphere等一些主流的web应用服务器那样保存即热部署。下面将介绍两个NodeJS中的开源热部署工具。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="nodejs" scheme="https://github.com/artdong/categories/nodejs/"/>
    
    
      <category term="node" scheme="https://github.com/artdong/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue移动端框架到底哪家强</title>
    <link href="https://github.com/artdong/2017/03/06/vue%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/artdong/2017/03/06/vue移动端框架/</id>
    <published>2017-03-06T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><p>2016年4月21日，阿里巴巴在Qcon大会上宣布跨平台移动开发工具Weex开放内测邀请。</p><p>Weex</p><p>是一套简单易用的跨平台开发方案，能以 web 的开发体验构建高性能、可扩展的 native 应用，为了做到这些，Weex 与 Vue</p><p>合作，使用 Vue 作为上层框架，并遵循 W3C 标准实现了统一的 JSEngine 和 DOM API，这样一来，你甚至可以使用其他框架驱动</p><p>Weex，打造三端一致的 native 应用。</p><p>Weex能够完美兼顾性能与动态性，支持iOS、安卓、YunOS及Web等多端部署。</p><hr>  <a id="more"></a><p>其工作原理</p><p>Weex</p><p>表面上是一个客户端技术，但实际上它串联起了从本地开发环境到云端部署和分发的整个链路。开发者首先可以在本地像撰写 web 页面一样撰写一个</p><p>app 的页面，然后编译成一段 JavaScript 代码，形成 Weex 的一个 JS bundle；在云端，开发者可以把生成的 JS</p><p>bundle 部署上去，然后通过网络请求或预下发的方式传递到用户的移动应用客户端；在移动应用客户端里，WeexSDK 会准备好一个</p><p>JavaScript 引擎，并且在用户打开一个 Weex 页面时执行相应的 JS bundle，并在执行过程中产生各种命令发送到 native</p><p>端进行的界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践；同时，如果用户没有安装移动应用，他仍然可以在浏览器里打开一个相同的</p><p>web 页面，这个页面是使用相同的页面源代码，通过浏览器里的 JavaScript 引擎运行起来的。</p><h2 id="Mint-UI"><a href="#Mint-UI" class="headerlink" title="Mint UI"></a>Mint UI</h2><p>基于 Vue.js 的移动端组件库</p><p>Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。</p><p>真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。</p><p>考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。</p><p>依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。</p><h2 id="vue-carbon"><a href="#vue-carbon" class="headerlink" title="vue-carbon"></a>vue-carbon</h2><p>基于 vuejs 1.0 开发 material design 风格的移动端 WEB UI 库</p><p>使用文档地址 <a href="https://myronliu347.github.io/vue-carbon/book/v0.5.0/index.html" target="_blank" rel="noopener">https://myronliu347.github.io/vue-carbon/book/v0.5.0/index.html</a></p><h2 id="Muse-UI"><a href="#Muse-UI" class="headerlink" title="Muse-UI"></a>Muse-UI</h2><p>基于 Vue 2.0 和 Material Desigin 的 UI 组件库</p><p>特性</p><p>1.组件丰富</p><p>Muse UI 基本实现了 Material Design 设计规范类的所有组件，另外还开发许多的功能性的组件</p><p>2.可定制</p><p>Muse UI 使用less文件，所有的颜色都有一个变量维护，通过编写 less 文件完成自定义主题，另外组件内部也提供一些修改效果的参数</p><p>3.基于 Vue 2.0</p><p>Muse UI 基于 Vue2.0 开发，Vue2.0是当下最快的前端框架之一，小巧，api友好，可用于开发的复杂单页应用</p><h2 id="VUWE"><a href="#VUWE" class="headerlink" title="VUWE"></a>VUWE</h2><p>vuwe是一款基于微信WeUI所开发的，专用于Vue2的组件库。</p><p>它与WeUI完全解耦。用户通过自定义WeUI的样式文件，可以方便地对VUWE实现定制化。</p><h2 id="vue-mobile"><a href="#vue-mobile" class="headerlink" title="vue-mobile"></a>vue-mobile</h2><p>vue-mobile is an UI Framework build with Vue.js for SPA:</p><p>Full Page Structure - header, content, footer</p><p>Page transition support by vue-router</p><p>Bunch of Powerful Components, easy to use and extend</p><p>high performance CSS3 Animation</p><p>1px border for all components - as well as round border</p><p>Write with Vue - the most important</p><h2 id="vonic"><a href="#vonic" class="headerlink" title="vonic"></a>vonic</h2><p>一个基于 vue.js 和 ionic 样式的 UI 框架，用于快速构建移动端单页应用。</p><p>和 ionic 的关系：没有关系，只是在样式方面以 ionic 的 css 文件为基础（做了一些调整）</p><h2 id="vux"><a href="#vux" class="headerlink" title="vux"></a>vux</h2><p>Vux（读音 [v’ju:z]，同views）是基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面。</p><p>基于webpack+vue-loader+vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。</p><p>vux-loader保证了组件按需使用，因此不用担心最终打包了整个vux的组件库代码。</p><p>vux并不完全依赖于WeUI，但是尽量保持整体UI样式接近WeUI的设计规范。最初目标是创建一个易用，实用，美观的移动端UI组件库，现在离理想状态还有不少距离，因此需要大家及时反馈问题及贡献代码。</p><p>即使你不使用vux的代码, 但能从源码得到一些参考那么也是件让人高兴的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Weex&quot;&gt;&lt;a href=&quot;#Weex&quot; class=&quot;headerlink&quot; title=&quot;Weex&quot;&gt;&lt;/a&gt;Weex&lt;/h2&gt;&lt;p&gt;2016年4月21日，阿里巴巴在Qcon大会上宣布跨平台移动开发工具Weex开放内测邀请。&lt;/p&gt;
&lt;p&gt;Weex&lt;/p&gt;
&lt;p&gt;是一套简单易用的跨平台开发方案，能以 web 的开发体验构建高性能、可扩展的 native 应用，为了做到这些，Weex 与 Vue&lt;/p&gt;
&lt;p&gt;合作，使用 Vue 作为上层框架，并遵循 W3C 标准实现了统一的 JSEngine 和 DOM API，这样一来，你甚至可以使用其他框架驱动&lt;/p&gt;
&lt;p&gt;Weex，打造三端一致的 native 应用。&lt;/p&gt;
&lt;p&gt;Weex能够完美兼顾性能与动态性，支持iOS、安卓、YunOS及Web等多端部署。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="vue" scheme="https://github.com/artdong/categories/vue/"/>
    
    
      <category term="vue" scheme="https://github.com/artdong/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>angular2入门，就这一篇就够了</title>
    <link href="https://github.com/artdong/2017/03/06/angular2%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/artdong/2017/03/06/angular2入门/</id>
    <published>2017-03-06T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><h2 id="背景与概念："><a href="#背景与概念：" class="headerlink" title="背景与概念："></a>背景与概念：</h2><p>AngularJS2 是一款开源JavaScript库，由Google维护，用来协助单一页面应用程序运行。</p><p>AngularJS2 是 Angular 1.x 的升级版本，性能上得到显著的提高，能很好的支持 Web 开发组件。</p><p>AngularJS2 发布于2016年9月份，它是基于ES6来开发的。</p><p>Angular2.x与Angular1.x 的区别</p><p>Angular2.x与Angular1.x 的区别类似 Java 和 JavaScript 或者说是雷锋与雷峰塔的区别，所以在学习Angular2.x时大家需要做好重新学习一门语言的心里准备。</p><h2 id="开工前的准备工作"><a href="#开工前的准备工作" class="headerlink" title="开工前的准备工作"></a>开工前的准备工作</h2><p>学习AngularJS2前，你需要具备基本的前端基础：HTML、CSS、JavaScript。此外你还需要了解 NPM 及 TypeScript。</p><hr> <a id="more"></a><h2 id="Angular-2-架构"><a href="#Angular-2-架构" class="headerlink" title="Angular 2 架构"></a>Angular 2 架构</h2><p>Angular 2 应用程序应用主要由以下 8 个部分组成：</p><p>1、模块 (Modules)</p><p>2、组件 (Components)</p><p>3、模板 (Templates)</p><p>4、元数据 (Metadata)</p><p>5、数据绑定 (Data Binding)</p><p>6、指令 (Directives)</p><p>7、服务 (Services)</p><p>8、依赖注入 (Dependency Injection)</p><p>下面看每个部分是如何相互工作的：</p><p>模板 (Templates)是由 Angular 扩展的 HTML 语法组成，组件 (Components)类用来管理这些模板，应用逻辑部分通过服务 (Services)来完成，然后在模块中打包服务与组件，最后通过引导根模块来启动应用。</p><p>接下来对以上 8 个部分分开解析：</p><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1.模块"></a>1.模块</h3><p>模块又一块代码组成，可用于执行一个简单的任务。</p><p>Angular 应用是由模块化的，它有自己的模块系统：NgModules。</p><p>每个 Angular 应该至少要有一个模块(根模块)，一般可以命名为：AppModule。</p><p>Angular 模块是一个带有 @NgModule 装饰器的类，它接收一个用来描述模块属性的元数据对象。</p><p>几个重要的属性如下：</p><p>declarations （声明）- 视图类属于这个模块。 Angular 有三种类型的视图类： 组件 、 指令 和 管道 。</p><p>exports- 声明（ declaration ）的子集，可用于其它模块中的组件模板 。</p><p>imports- 本模块组件模板中需要由其它导出类的模块。</p><p>providers- 服务的创建者。本模块把它们加入全局的服务表中，让它们在应用中的任何部分都可被访问到。</p><p>bootstrap- 应用的主视图，称为根组件，它是所有其它应用视图的宿主。只有根模块需要设置 bootstrap 属性中。</p><p>一个最简单的根模块，eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;NgModule&#125;<span class="keyword">from</span><span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;BrowserModule&#125;<span class="keyword">from</span><span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;<span class="attr">imports</span>: [BrowserModule],</span><br><span class="line"></span><br><span class="line">providers: [Logger],</span><br><span class="line"></span><br><span class="line">declarations: [AppComponent],</span><br><span class="line"></span><br><span class="line">exports: [AppComponent],</span><br><span class="line"></span><br><span class="line">bootstrap: [AppComponent]&#125;)exportclassAppModule&#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来通过引导根模块来启动应用，开发过程通常在 main.ts 文件中来引导 AppModule ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;platformBrowserDynamic&#125;<span class="keyword">from</span><span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>&#123;AppModule&#125;<span class="keyword">from</span><span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure><h3 id="2-组件-Components"><a href="#2-组件-Components" class="headerlink" title="2.组件(Components)"></a>2.组件(Components)</h3><p>组件是一个模板的控制类用于处理应用和逻辑页面的视图部分。</p><p>组件是构成 Angular 应用的基础和核心，可用于整个应用程序中。</p><p>组件知道如何渲染自己及配置依赖注入。</p><p>组件通过一些由属性和方法组成的 API 与视图交互。</p><p>创建 Angular 组件的方法有三步：</p><p>从 @angular/core 中引入 Component 修饰器</p><p>建立一个普通的类，并用 @Component 修饰它</p><p>在 @Component 中，设置 selector自定义标签，以及 template模板</p><h3 id="3-模板-Templates"><a href="#3-模板-Templates" class="headerlink" title="3.模板(Templates)"></a>3.模板(Templates)</h3><p>Angular模板的默认语言就是HTML。</p><p>我们可以通过使用模板来定义组件的视图来告诉 Angular 如何显示组件。以下是一个简单是实例：</p><p>网站地址 : [object Object]</p><h3 id="4-元数据-Metadata"><a href="#4-元数据-Metadata" class="headerlink" title="4.元数据(Metadata)"></a>4.元数据(Metadata)</h3><p>元数据告诉 Angular 如何处理一个类。</p><p>考虑以下情况我们有一个组件叫作 Component ，它是一个类，直到我们告诉 Angular 这是一个组件为止。</p><p>你可以把元数据附加到这个类上来告诉 Angular Component 是一个组件。</p><p>在 TypeScript 中，我们用 装饰器 (decorator) 来附加元数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg：</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line"></span><br><span class="line">selector : <span class="string">'mylist'</span>,</span><br><span class="line"></span><br><span class="line">template : <span class="string">'菜鸟教程'</span></span><br><span class="line"></span><br><span class="line">directives : [ComponentDetails]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ListComponent</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>@Component 装饰器能接受一个配置对象，并把紧随其后的类标记成了组件类。</p><p>Angular 会基于这些信息创建和展示组件及其视图。</p><p>@Component 中的配置项说明：</p><p>selector- 一个 css 选择器，它告诉 Angular 在 父级 HTML 中寻找一个  标签，然后创建该组件，并插入此标签中。</p><p>templateUrl- 组件 HTML 模板的地址。</p><p>directives- 一个数组，包含 此 模板需要依赖的组件或指令。</p><p>providers- 一个数组，包含组件所依赖的服务所需要的依赖注入提供者。</p><h3 id="5-数据绑定-Data-binding"><a href="#5-数据绑定-Data-binding" class="headerlink" title="5.数据绑定(Data binding)"></a>5.数据绑定(Data binding)</h3><p>数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。</p><p>通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。</p><p>插值: 在 HTML 标签中显示组件值。</p>angular2入门，就这一篇就够了<p>属性绑定: 把元素的属性设置为组件中属性的值。</p><p>事件绑定: 在组件方法名被点击时触发。</p><p>双向绑: 使用Angular里的NgModel指令可以更便捷的进行双向绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(input)=<span class="string">"currentUser.firstName=$event.target.value"</span> &gt;</span><br></pre></td></tr></table></figure><h3 id="6-指令（Directives）"><a href="#6-指令（Directives）" class="headerlink" title="6.指令（Directives）"></a>6.指令（Directives）</h3><p>Angular模板是动态的 。当 Angular 渲染它们时，它会根据指令对 DOM 进行修改。</p><p>指令是一个带有”指令元数据”的类。在 TypeScript 中，要通过 @Directive 装饰器把元数据附加到类上。</p><p>在Angular中包含以下三种类型的指令：</p><p>属性指令：以元素的属性形式来使用的指令。</p><p>结构指令：用来改变DOM树的结构</p><p>组件：作为指令的一个重要子类，组件本质上可以看作是一个带有模板的指令。</p><p>*ngFor 告诉 Angular 为 sites 列表中的每个项生成一个</p><p>标签。</p><p>*ngIf 表示只有在选择的项存在时，才会包含 SiteDetail 组件。</p><h3 id="7-服务-Services"><a href="#7-服务-Services" class="headerlink" title="7.服务(Services)"></a>7.服务(Services)</h3><p>Angular2中的服务是封装了某一特定功能，并且可以通过注入的方式供他人使用的独立模块。</p><p>服务分为很多种，包括：值、函数，以及应用所需的特性。</p><p>例如，多个组件中出现了重复代码时，把重复代码提取到服务中实现代码复用。</p><p>以下是几种常见的服务：</p><p>日志服务</p><p>数据服务</p><p>消息总线</p><p>税款计算器</p><p>应用程序配置</p><p>以下实例是一个日志服务，用于把日志记录到浏览器的控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">log(msg: any) &#123; <span class="built_in">console</span>.log(msg); &#125;</span><br><span class="line"></span><br><span class="line">error(msg: any) &#123; <span class="built_in">console</span>.error(msg); &#125;</span><br><span class="line"></span><br><span class="line">warn(msg: any) &#123; <span class="built_in">console</span>.warn(msg); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-依赖注入"><a href="#8-依赖注入" class="headerlink" title="8.依赖注入"></a>8.依赖注入</h3><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫”依赖查找”（Dependency Lookup）。</p><p>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><p>在传统的开发模式中，调用者负责管理所有对象的依赖，循环依赖一直是梦魇，而在依赖注入模式中，这个管理权交给了注入器(Injector)，它在软件运行时负责依赖对象的替换，而不是在编译时。这种控制反转，运行注入的特点即是依赖注入的精华所在。</p><p>Angular 能通过查看构造函数的参数类型，来得知组件需要哪些服务。 例如， SiteListComponent 组件的构造函数需要一个 SiteService:</p><p>constructor(private service: HeroService) { }</p><p>当 Angular 创建组件时，会首先为组件所需的服务找一个注入器（ Injector ） 。</p><p>注入器是一个维护服务实例的容器，存放着以前创建的实例。</p><p>如果容器中还没有所请求的服务实例，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular 。</p><p>当所有的服务都被解析完并返回时， Angular 会以这些服务为参数去调用组件的构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景与概念：&quot;&gt;&lt;a href=&quot;#背景与概念：&quot; class=&quot;headerlink&quot; title=&quot;背景与概念：&quot;&gt;&lt;/a&gt;背景与概念：&lt;/h2&gt;&lt;p&gt;AngularJS2 是一款开源JavaScript库，由Google维护，用来协助单一页面应用程序运行。&lt;/p&gt;
&lt;p&gt;AngularJS2 是 Angular 1.x 的升级版本，性能上得到显著的提高，能很好的支持 Web 开发组件。&lt;/p&gt;
&lt;p&gt;AngularJS2 发布于2016年9月份，它是基于ES6来开发的。&lt;/p&gt;
&lt;p&gt;Angular2.x与Angular1.x 的区别&lt;/p&gt;
&lt;p&gt;Angular2.x与Angular1.x 的区别类似 Java 和 JavaScript 或者说是雷锋与雷峰塔的区别，所以在学习Angular2.x时大家需要做好重新学习一门语言的心里准备。&lt;/p&gt;
&lt;h2 id=&quot;开工前的准备工作&quot;&gt;&lt;a href=&quot;#开工前的准备工作&quot; class=&quot;headerlink&quot; title=&quot;开工前的准备工作&quot;&gt;&lt;/a&gt;开工前的准备工作&lt;/h2&gt;&lt;p&gt;学习AngularJS2前，你需要具备基本的前端基础：HTML、CSS、JavaScript。此外你还需要了解 NPM 及 TypeScript。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="angular2" scheme="https://github.com/artdong/categories/angular2/"/>
    
    
      <category term="angular" scheme="https://github.com/artdong/tags/angular/"/>
    
      <category term="angular2" scheme="https://github.com/artdong/tags/angular2/"/>
    
  </entry>
  
  <entry>
    <title>webpack loader全家桶</title>
    <link href="https://github.com/artdong/2017/03/06/webpack%20loader%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <id>https://github.com/artdong/2017/03/06/webpack loader全家桶/</id>
    <published>2017-03-06T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><p>webpack的loaders是一大特色，也是很重要的一部分。下面介绍一些常用的loader。</p><hr>  <a id="more"></a><h2 id="loaders之-js处理"><a href="#loaders之-js处理" class="headerlink" title="loaders之 js处理"></a>loaders之 js处理</h2><p>babel-loader</p><p>jsx-loader</p><p>npm install –save-dev babel-core babel-preset-es2015 babel-loader jsx-loader</p><h2 id="loaders之预处理"><a href="#loaders之预处理" class="headerlink" title="loaders之预处理"></a>loaders之预处理</h2><p>css-loader 处理css中路径引用等问题</p><p>style-loader 动态把样式写入css</p><p>sass-loader scss编译器</p><p>less-loader less编译器</p><p>postcss-loader scss再处理</p><p>npm install –save -dev css-loader style-loader sass-loader less-loader postcss-loader</p><h2 id="loaders之-json处理"><a href="#loaders之-json处理" class="headerlink" title="loaders之 json处理"></a>loaders之 json处理</h2><p>json-loader</p><p>npm install –save-dev json-loader</p><h2 id="loaders之-图片处理"><a href="#loaders之-图片处理" class="headerlink" title="loaders之 图片处理"></a>loaders之 图片处理</h2><p>url-loader</p><p>npm install –save-dev url-loader</p><h2 id="loaders之-文件处理"><a href="#loaders之-文件处理" class="headerlink" title="loaders之 文件处理"></a>loaders之 文件处理</h2><p>file-loader</p><p>npm install –save-dev file-loader</p><h2 id="loaders之-html处理"><a href="#loaders之-html处理" class="headerlink" title="loaders之 html处理"></a>loaders之 html处理</h2><p>raw-loader</p><p>npm install –save-dev raw-loader</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;p&gt;webpack的loaders是一大特色，也是很重要的一部分。下面介绍一些常用的loader。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://github.com/artdong/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://github.com/artdong/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>你不得不知的Ionic3新特性</title>
    <link href="https://github.com/artdong/2017/03/06/%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Ionic3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://github.com/artdong/2017/03/06/你不得不知的Ionic3新特性/</id>
    <published>2017-03-06T08:30:11.000Z</published>
    <updated>2019-07-23T06:04:42.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><hr></blockquote><p>Ionic3新特性：</p><h2 id="Angular-4-0"><a href="#Angular-4-0" class="headerlink" title="Angular 4.0"></a>Angular 4.0</h2><p>新的版本下，改进 AOT 编译器，分离 animations 包，缩小生成后的代码量，运行更快，改进ngIf 和ngFor 等具体内容可以访问<a href="http://angularjs.blogspot.sg/2017/03/angular-400-now-available.html来查看。" target="_blank" rel="noopener">http://angularjs.blogspot.sg/2017/03/angular-400-now-available.html来查看。</a></p><h2 id="typescript-2-1-2-2的支持"><a href="#typescript-2-1-2-2的支持" class="headerlink" title="typescript 2.1, 2.2的支持"></a>typescript 2.1, 2.2的支持</h2><p>这一次的更新将提升typescript应用构建和类型检查的速度并且引入了对mix-in的支持等具体可以访问<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html来查看。" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html来查看。</a></p><hr> <a id="more"></a><h2 id="IonicPage装饰器"><a href="#IonicPage装饰器" class="headerlink" title="@IonicPage装饰器"></a>@IonicPage装饰器</h2><p>ionic2中导航器不是基于url的，如果想使用url访问就要通过DeepLinker来实现，这是非常麻烦的，而在新版本我们可以通过@IonicPage装饰器来实现。并且可以更轻松的在项目中设置延迟加载，设置延迟加载页面的优先级，并为每个页面自定义配置。</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>Ionic3.0版本开始，支持了延迟加载，我们可以将某些模块设置为延时加载，只有用户打开相关的页面的时候，这个模块所在的js才会被下载，这样能减少用户初次下载的文件的大小。</p><p>总的来说，升级Ionic3将使我们的项目变得更小，更快，而更吸引我们的则是懒加载，不仅仅是加快了app首次的启动时间，更多的是配合上@IonicPage可以非常方便部署web版本，让每次进入不用去请求庞大的js文件，做到首屏的快速加载，write once run anywhere，这些就是我们需要升级Ionic3的原因。</p><p>那么，问题来了，怎样升级到Ionic3呢？</p><p>首先访问<a href="https://github.com/ionic-team/ionic2-app-base/复制package.json的dependencies和devDependencies到自己的项目中后删除掉原本的node_modules文件夹，运行npm">https://github.com/ionic-team/ionic2-app-base/复制package.json的dependencies和devDependencies到自己的项目中后删除掉原本的node_modules文件夹，运行npm</a> install重新下载依赖。</p><p>将BrowserModule加入你的app/app.module.ts<br>import { BrowserModule } from ‘@angular/platform-browser’;<br>在app.module.ts中将BrowserModule添加进imports中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imports: [   BrowserModule,   IonicModule.forRoot(MyApp) ],</span><br></pre></td></tr></table></figure><p>由于ionic3将ionic-native拆开成个各种小的包@ionic-native/*,splash-screen，status-bar等之前ionic-native中的模块都需要重新引入具体可以参照<a href="http://ionicframework.com/docs/native/来对号入座。" target="_blank" rel="noopener">http://ionicframework.com/docs/native/来对号入座。</a></p><p>最后打开cmd控制台运行ionic serve</p><p>开始享受ionic3带来的改变吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;hr&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ionic3新特性：&lt;/p&gt;
&lt;h2 id=&quot;Angular-4-0&quot;&gt;&lt;a href=&quot;#Angular-4-0&quot; class=&quot;headerlink&quot; title=&quot;Angular 4.0&quot;&gt;&lt;/a&gt;Angular 4.0&lt;/h2&gt;&lt;p&gt;新的版本下，改进 AOT 编译器，分离 animations 包，缩小生成后的代码量，运行更快，改进ngIf 和ngFor 等具体内容可以访问&lt;a href=&quot;http://angularjs.blogspot.sg/2017/03/angular-400-now-available.html来查看。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://angularjs.blogspot.sg/2017/03/angular-400-now-available.html来查看。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;typescript-2-1-2-2的支持&quot;&gt;&lt;a href=&quot;#typescript-2-1-2-2的支持&quot; class=&quot;headerlink&quot; title=&quot;typescript 2.1, 2.2的支持&quot;&gt;&lt;/a&gt;typescript 2.1, 2.2的支持&lt;/h2&gt;&lt;p&gt;这一次的更新将提升typescript应用构建和类型检查的速度并且引入了对mix-in的支持等具体可以访问&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html来查看。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html来查看。&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="ionic3" scheme="https://github.com/artdong/categories/ionic3/"/>
    
    
      <category term="ionic" scheme="https://github.com/artdong/tags/ionic/"/>
    
      <category term="ionic3" scheme="https://github.com/artdong/tags/ionic3/"/>
    
  </entry>
  
</feed>
