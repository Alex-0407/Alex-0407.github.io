<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[说说你对Promise的理解？]]></title>
    <url>%2Fblog%2F2019%2F07%2F06%2F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Promise 核心 Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要） Promise 规范中规定了，promise 的状态只有3种： pending fulfilled rejectedPromise 的状态一旦改变则不会再改变。 Promise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。 ES6 Promise细节 Promise 构造器中必须传入函数，否则会抛出错误。(没有执行器还怎么做异步操作。。。) Promise.prototype上的 catch(onrejected) 方法是 then(null,onrejected) 的别名,并且会处理链之前的任何的reject。 Promise.prototype 上的 then和 catch 方法总会返回一个全新的 Promise 对象。 如果传入构造器的函数中抛出了错误,该 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。 then 中的回调如果抛出错误，返回的 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。 then 中的回调返回值会影响 then 返回的 promise 对象。 Promise优点 Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了。 解决回调地狱（Callback Hell）问题 Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： 1job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。 Promise.all()并行执行异步任务 Promise.race()获得先返回的结果即可 eg.同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。 Promise如何解决这两个问题 解决可读性的问题 这一点不用多说，用过Promise的人很容易明白。Promise的应用相当于给了你一张可以把解题思路清晰记录下来的草稿纸，你不在需要用脑子去记忆执行顺序。 解决信任问题 Promise并没有取消控制反转，而是把反转出去的控制再反转一次，也就是反转了控制反转。 这种机制有点像事件的触发。它与普通的回调的方式的区别在于，普通的方式，回调成功之后的操作直接写在了回调函数里面，而这些操作的调用由第三方控制。在Promise的方式中，回调只负责成功之后的通知，而回调成功之后的操作放在了then的回调里面，由Promise精确控制。 Promise有这些特征：只能决议一次，决议值只能有一个，决议之后无法改变。任何then中的回调也只会被调用一次。Promise的特征保证了Promise可以解决信任问题。 对于回调过早的问题，由于Promise只能是异步的，所以不会出现异步的同步调用。即便是在决议之前的错误，也是异步的，并不是会产生同步（调用过早）的困扰。1234567891011let a = new Promise((resolve, reject) =&gt; &#123; let b = 1 + c; // ReferenceError: c is not defined，错误会在下面的a打印出来之后报出。 resolve(true);&#125;)console.log(1, a);a.then(res =&gt; &#123; console.log(2, res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 对于回调过晚或没有调用的问题，Promise本身不会回调过晚，只要决议了，它就会按照规定运行。至于服务器或者网络的问题，并不是Promise能解决的，一般这种情况会使用Promise的竞态APIPromise.race加一个超时的时间：1234567891011function timeoutPromise(delay) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; reject(&quot;Timeout!&quot;); &#125;, delay); &#125;);&#125;Promise.race([doSomething(), timeoutPromise(3000)]).then(...).catch(...); 对于回调次数太少或太多的问题，由于Promise只能被决议一次，且决议之后无法改变，所以，即便是多次回调，也不会影响结果，决议之后的调用都会被忽略。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise和setTimeout执行顺序是怎样的？]]></title>
    <url>%2Fblog%2F2019%2F07%2F05%2Fpromise%E5%92%8CsetTimeout%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%2F</url>
    <content type="text"><![CDATA[写出下列程序运行结果并做出解释： 1234567891011121314setTimeout(function()&#123; console.log(1);&#125;,0); new Promise(function(resolve) &#123; console.log(2) for(let i=0; i&lt;10000 ; i++ ) &#123; i==9999 &amp;&amp; resolve(); &#125; console.log(3) &#125;).then(function()&#123; console.log(4) &#125;); console.log(5); 这个就涉及到事件循环（Event Loop） JS运行时，对代码执行顺序的一个算法（任务调度算法） JS 分类：同步任务和异步任务JS 的执行机制： 首先判断JS代码是同步还是异步，同步就进入主线程，异步就进入 event table 异步任务在 event table 中注册函数，当满足触发条件后，被推入event queue 同步任务进入主线程后一直执行，直到主线程空闲时，才回去 event queue 中查看是否有可执行的异步任务，如果有就推入主线程 event loop 里有维护两个不同的异步任务队列 macro Tasks（宏任务）：script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering micro Tasks（微任务）：process.nextTick, Promise（浏览器实现的原生Promise）, Object.observe, MutationObserver, MessageChannel 每次执行一段代码（一个script标签）都是一个 macroTask执行流程： event loop 开始 从macro Tasks 队列抽取一个任务，执行 micro Tasks 清空队列执行，若有任务不可执行，推入下一轮 micro Tasks 结束 event loop 浏览器执行代码的过程如下整个流程 那么回到题目上去，就是1234567891011121314setTimeout(function()&#123; console.log(1); // 1-放入宏任务队列，7-执行下一轮事件循环，宏任务输出1&#125;,0); new Promise(function(resolve) &#123; console.log(2); // 2-同步输出 2 for(let i=0; i&lt;10000 ; i++ ) &#123; i==9999 &amp;&amp; resolve(); &#125; console.log(3); // 4-同步输出 3&#125;).then(function()&#123; console.log(4); // 3-放入微任务队列，6-回到微任务队列，执行剩余的微任务，输出4&#125;); console.log(5); // 5-同步输出 5]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.assign 是浅拷贝还是深拷贝？实现深拷贝的方法有哪些？]]></title>
    <url>%2Fblog%2F2019%2F07%2F04%2FObject.assign%20%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。 Object.assign 不会在那些source对象值为 null或 undefined 的时候抛出错误。 针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign({},srcObj);得到的新对象为深拷贝；如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。 深拷贝的几种实现方法JSON.stringify 和 JSON.parse 用 JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。 可以转成 JSON 格式的对象才能使用这种方法，如果对象中包含 function 或 RegExp 这些就不能用这种方法了。 123456//通过js的内置对象JSON来进行数组对象的深拷贝function deepClone(obj) &#123; let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone;&#125; Object.assign()拷贝当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。 通过jQuery的extend方法实现深拷贝1234567891011let $ = require(&apos;jquery&apos;);let obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;let obj2 = $.extend(true, &#123;&#125;, obj1); lodash.cloneDeep()实现深拷贝1234567let _ = require(&apos;lodash&apos;);let obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;let obj2 = _.cloneDeep(obj1); 使用递归的方式实现深拷贝123456789101112131415161718function _deepClone(source) &#123; let target; if (typeof source === &apos;object&apos;) &#123; target = Array.isArray(source) ? [] : &#123;&#125; for (let key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (typeof source[key] !== &apos;object&apos;) &#123; target[key] = source[key] &#125; else &#123; target[key] = _deepClone(source[key]) &#125; &#125; &#125; &#125; else &#123; target = source &#125; return target&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用的清除浮动方法有哪些？]]></title>
    <url>%2Fblog%2F2019%2F07%2F03%2Fcss%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[父级元素添加伪元素 12345.clear-float:after &#123; content: ''; display: block; clear: both;&#125; 在与浮动元素平级的最后面添加新元素 div.clear 123.clear &#123; clear: both;&#125; 在父级元素添加样式 overflow: auto; 或者 overflow: hidden; 会存在兼容性问题。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现几种常见排序算法]]></title>
    <url>%2Fblog%2F2019%2F07%2F02%2Fjs%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js实现几种常见排序算法。 冒泡排序： 1234567891011121314151617181920const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function bubbleSort(arr) &#123; let len = arr.length; if(len &gt;= 1) &#123; for(let i = 0;i &lt; len - 1; i++) &#123; for(let j = 0;j &lt; len - 1 - i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr)); 冒泡排序优化版： 123456789101112131415161718192021222324252627282930313233const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function bubbleSort(arr) &#123; let len = arr.length; let lastExchangeIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 let sortBorder = len - 1; if(len &gt;= 1) &#123; for(let i = 0;i &lt; len; i++) &#123; //有序标记，每一轮的初始是true let isSorted = true; for(let j = 0;j &lt; sortBorder - i; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; //有元素交换，所以不是有序，标记变为false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex; if(isSorted) &#123; //有序,跳出循环 break; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr)); 选择排序： 12345678910111213141516171819202122const arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];function selectionSort(arr) &#123; let len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125;console.log(selectionSort(arr)); 选择排序优化版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];function selectionSort(arr) &#123; let len = arr.length; let left = 0; let right = len - 1; while (left &lt; right) &#123; let max = left;//记录无序区最大元素下标 let min = left;//记录无序区最小元素下标 let j = 0; for (j = left + 1; j &lt;= right; j++) &#123; //找最大元素下标 if (arr[j] &lt; arr[min]) &#123; min = j; &#125; //找最小元素下标 if (arr[j] &gt; arr[max]) &#123; max = j; &#125; &#125; //最小值如果是第一个则没有必要交换 if (min != left) &#123; let tmp = arr[left]; arr[left] = arr[min]; arr[min] = tmp; &#125; //这里很重要，如果最大元素下标是left,前面已经和最小元素交换了，此时最大元素下标应该是min if (max == left) &#123; max = min; &#125; //最大值如果是最后一个则没必要交换 if (max != right) &#123; let tmp = arr[right]; arr[right] = arr[max]; arr[max] = tmp; &#125; left++; right--; &#125; return arr;&#125;console.log(selectionSort(arr)); 插入排序： 123456789101112131415161718const arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];function insertSort(arr) &#123; const len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125;console.log(insertSort(arr));]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 数据类型有哪些？]]></title>
    <url>%2Fblog%2F2019%2F07%2F01%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B7%2B3%2F</url>
    <content type="text"><![CDATA[JS 7 种基本数据类型（原始类型），即 （Undefined、Null、Boolean、Number 、String） + （Symbol、BigInt）和 3种引用数据类型：对象(Object)、数组(Array)、函数(Function)。 基本类型值：指的是保存在栈内存中的简单数据段。 引用类型值：指的是那些保存在堆内存中的对象。变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值。 注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值; BigInt即是第七种基本类型，V8引擎v6.7 默认启用对 BigInt 的支持。 Symbol用法 语法 Symbol (value) eg. 12let a=Symbol (&quot;welcome&quot;);console.log(a); //输出 Symbol(welcome) BigInt用法 语法 BigInt(value) || 数字后面加n; eg. 123let b1 = BigInt(10);let b2 = 10n;console.log(b1,b2); //输出 10n 10n 更多经典前端面试题，请到github查看或参与讨论https://github.com/daily-interview/fe-interview]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS - 定位属性position使用详解（static、relative、fixed、absolute）]]></title>
    <url>%2Fblog%2F2018%2F07%2F23%2Fcss-position%2F</url>
    <content type="text"><![CDATA[position 属性介绍 （1）position 属性自 CSS2 起就有了，该属性规定元素的定位类型。所有主流浏览器都支持 position 属性。 （2）position 的可选值有四个：static、relative、absolute、fixed。下面分别进行介绍。（其实还有个 inherit，不过这个是 IE 特有的，这里就不做讨论） position: static（默认值） 1，基本介绍 （1）static 是默认值。表示没有定位，或者说不算具有定位属性。 （2）如果元素 position 属性值为 static（或者未设 position 属性），该元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 2，使用样例 css: 1234567&lt;style&gt; div &#123; width: 200px; height: 100px; background-color: #C9FFFF; &#125;&lt;/style&gt; html: 123&lt;div&gt;&lt;/div&gt;&lt;input type=&quot;text&quot;/&gt;` 我们不设置元素的 postion 属性值，那么默认的显示效果如下： position: relative（相对定位） 1，基本介绍 （1）relative 生成相对定位的元素，相对于其正常位置进行定位。 （2）相对定位完成的过程如下： 首先按默认方式（static）生成一个元素(并且元素像层一样浮动了起来)。 然后相对于以前的位置移动，移动的方向和幅度由 left、right、top、bottom 属性确定，偏移前的位置保留不动。 2，样例代码 下面代码将文本输入框 position 设置为 relative（相对定位），并且相对于默认的位置向右、向上分别移动 15 个像素。 css: 1234567891011div &#123; width: 200px; height: 100px; background-color: #C9FFFF;&#125; input &#123; position: relative; left: 15px; top: -15px;&#125; html: 12&lt;div&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; /&gt; 运行效果如下： position: absolute（绝对定位） 1，基本介绍 （1）absolute 生成绝对定位的元素。 （2）绝对定位的元素使用 left、right、top、bottom 属性相对于其最接近的一个具有定位属性的父元素进行绝对定位。 （3）如果不存在这样的父元素，则相对于 body 元素，即相对于浏览器窗口。 2，样例代码 下面代码让标题元素相对于它的父容器做绝对定位（注意父容器 position 要设置为 relative）。 同时通过 top 属性让标题元素上移，使其覆盖在父容器的上边框。 最后通过 left 和 margin-left 配合实现这个绝对定位元素的水平居中。 css: 123456789101112131415161718192021222324#box &#123; width: 200px; height: 100px; -webkit-box-flex:1; border: 1px solid #28AE65; border-radius:6px; padding: 20px; position: relative; font-size: 12px;&#125; #title &#123; background: #FFFFFF; color: #28AE65; font-size: 15px; text-align: center; width: 70px; height: 20px; line-height: 20px; position: absolute; top: -10px; left: 50%; margin-left: -35px;&#125; html: 1234&lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;title&quot;&gt;标题&lt;/div&gt; 欢迎访问我的博客&lt;/div&gt; 运行效果如下，标题元素虽然是在边框容器的内部。但由于其使用绝对定位，并做位置调整，最后显示效果就是覆盖在父容器边框上。 标题 嘿，guys！欢迎访问我的博客。 position: fixed（固定定位） 1，基本介绍 （1）fixed 生成绝对定位的元素，该元素相对于浏览器窗口进行定位。 （2）固定定位的元素不会随浏览器窗口的滚动条滚动而变化，也不会受文档流动影响，而是始终位于浏览器窗口内视图的某个位置。 2，样例代码 （1）下面代码让输入框位于浏览器窗口的底部。 css: 1234input &#123; position: fixed; bottom: 10px;&#125; html: 1234567&lt;ol&gt; &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt; &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt; &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt; &lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;li&gt;数据&lt;/li&gt;&lt;/ol&gt;&lt;input type=&quot;text&quot; /&gt; （2）可以看到不管滚动条如何滚动，输入框始终处于窗口的最下方。 数据数据数据数据数据数据 数据数据数据数据数据数据 数据数据数据数据数据数据 数据数据数据数据数据数据]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2组件之间的交互]]></title>
    <url>%2Fblog%2F2018%2F06%2F08%2Fangular2%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[通过输入型绑定把数据从父组件传到子组件。HeroChildComponent 有两个输入型属性，它们通常带@Input 装饰器。component-interaction/src/app/hero-child.component.ts import { Component, Input } from &apos;@angular/core&apos;; import { Hero } from &apos;./hero&apos;; @Component({ selector: &apos;app-hero-child&apos;, template: ` &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt; &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt; ` }) export class HeroChildComponent { @Input() hero: Hero; @Input(&apos;master&apos;) masterName: string; } 第二个 @Input 为子组件的属性名 masterName 指定一个别名 master(译者注：不推荐为起别名，请参见风格指南). 父组件 HeroParentComponent 把子组件的 HeroChildComponent 放到 *ngFor 循环器中，把自己的 master 字符串属性绑定到子组件的 master 别名上，并把每个循环的 hero 实例绑定到子组件的 hero 属性。component-interaction/src/app/hero-parent.component.ts import { Component } from &apos;@angular/core&apos;; import { HEROES } from &apos;./hero&apos;; @Component({ selector: &apos;app-hero-parent&apos;, template: ` &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt; &lt;app-hero-child *ngFor=&quot;let hero of heroes&quot; [hero]=&quot;hero&quot; [master]=&quot;master&quot;&gt; &lt;/app-hero-child&gt; ` }) export class HeroParentComponent { heroes = HEROES; master = &apos;Master&apos;; } Angular 2 架构Angular 2 应用程序应用主要由以下 8 个部分组成： 1、模块 (Modules) 2、组件 (Components) 3、模板 (Templates) 4、元数据 (Metadata) 5、数据绑定 (Data Binding) 6、指令 (Directives) 7、服务 (Services) 8、依赖注入 (Dependency Injection) 下面看每个部分是如何相互工作的： 模板 (Templates)是由 Angular 扩展的 HTML 语法组成，组件 (Components)类用来管理这些模板，应用逻辑部分通过服务 (Services)来完成，然后在模块中打包服务与组件，最后通过引导根模块来启动应用。 接下来对以上 8 个部分分开解析： 1.模块模块又一块代码组成，可用于执行一个简单的任务。 Angular 应用是由模块化的，它有自己的模块系统：NgModules。 每个 Angular 应该至少要有一个模块(根模块)，一般可以命名为：AppModule。 Angular 模块是一个带有 @NgModule 装饰器的类，它接收一个用来描述模块属性的元数据对象。 几个重要的属性如下： declarations （声明）- 视图类属于这个模块。 Angular 有三种类型的视图类： 组件 、 指令 和 管道 。 exports- 声明（ declaration ）的子集，可用于其它模块中的组件模板 。 imports- 本模块组件模板中需要由其它导出类的模块。 providers- 服务的创建者。本模块把它们加入全局的服务表中，让它们在应用中的任何部分都可被访问到。 bootstrap- 应用的主视图，称为根组件，它是所有其它应用视图的宿主。只有根模块需要设置 bootstrap 属性中。 一个最简单的根模块，eg: 1234567891011121314import&#123;NgModule&#125;from'@angular/core';import&#123;BrowserModule&#125;from'@angular/platform-browser';@NgModule(&#123;imports: [BrowserModule],providers: [Logger],declarations: [AppComponent],exports: [AppComponent],bootstrap: [AppComponent]&#125;)exportclassAppModule&#123;&#125; 接下来通过引导根模块来启动应用，开发过程通常在 main.ts 文件中来引导 AppModule ： 123456import&#123;platformBrowserDynamic&#125;from'@angular/platform-browser-dynamic';import&#123;AppModule&#125;from'./app.module';platformBrowserDynamic().bootstrapModule(AppModule); 2.组件(Components)组件是一个模板的控制类用于处理应用和逻辑页面的视图部分。 组件是构成 Angular 应用的基础和核心，可用于整个应用程序中。 组件知道如何渲染自己及配置依赖注入。 组件通过一些由属性和方法组成的 API 与视图交互。 创建 Angular 组件的方法有三步： 从 @angular/core 中引入 Component 修饰器 建立一个普通的类，并用 @Component 修饰它 在 @Component 中，设置 selector自定义标签，以及 template模板 3.模板(Templates)Angular模板的默认语言就是HTML。 我们可以通过使用模板来定义组件的视图来告诉 Angular 如何显示组件。以下是一个简单是实例： 网站地址 : [object Object] 4.元数据(Metadata)元数据告诉 Angular 如何处理一个类。 考虑以下情况我们有一个组件叫作 Component ，它是一个类，直到我们告诉 Angular 这是一个组件为止。 你可以把元数据附加到这个类上来告诉 Angular Component 是一个组件。 在 TypeScript 中，我们用 装饰器 (decorator) 来附加元数据。 12345678910111213141516eg：@Component(&#123;selector : 'mylist',template : '菜鸟教程'directives : [ComponentDetails]&#125;)export class ListComponent&#123;...&#125;` @Component 装饰器能接受一个配置对象，并把紧随其后的类标记成了组件类。 Angular 会基于这些信息创建和展示组件及其视图。 @Component 中的配置项说明： selector- 一个 css 选择器，它告诉 Angular 在 父级 HTML 中寻找一个 标签，然后创建该组件，并插入此标签中。 templateUrl- 组件 HTML 模板的地址。 directives- 一个数组，包含 此 模板需要依赖的组件或指令。 providers- 一个数组，包含组件所依赖的服务所需要的依赖注入提供者。 5.数据绑定(Data binding)数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。 通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。 插值: 在 HTML 标签中显示组件值。 angular2组件之间的交互 属性绑定: 把元素的属性设置为组件中属性的值。 事件绑定: 在组件方法名被点击时触发。 双向绑: 使用Angular里的NgModel指令可以更便捷的进行双向绑定。 12(input)="currentUser.firstName=$event.target.value" &gt; 6.指令（Directives）Angular模板是动态的 。当 Angular 渲染它们时，它会根据指令对 DOM 进行修改。 指令是一个带有”指令元数据”的类。在 TypeScript 中，要通过 @Directive 装饰器把元数据附加到类上。 在Angular中包含以下三种类型的指令： 属性指令：以元素的属性形式来使用的指令。 结构指令：用来改变DOM树的结构 组件：作为指令的一个重要子类，组件本质上可以看作是一个带有模板的指令。 *ngFor 告诉 Angular 为 sites 列表中的每个项生成一个 标签。 *ngIf 表示只有在选择的项存在时，才会包含 SiteDetail 组件。 7.服务(Services)Angular2中的服务是封装了某一特定功能，并且可以通过注入的方式供他人使用的独立模块。 服务分为很多种，包括：值、函数，以及应用所需的特性。 例如，多个组件中出现了重复代码时，把重复代码提取到服务中实现代码复用。 以下是几种常见的服务： 日志服务 数据服务 消息总线 税款计算器 应用程序配置 以下实例是一个日志服务，用于把日志记录到浏览器的控制台： 12345678910export class Logger &#123;log(msg: any) &#123; console.log(msg); &#125;error(msg: any) &#123; console.error(msg); &#125;warn(msg: any) &#123; console.warn(msg); &#125;&#125; 8.依赖注入控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫”依赖查找”（Dependency Lookup）。 通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 在传统的开发模式中，调用者负责管理所有对象的依赖，循环依赖一直是梦魇，而在依赖注入模式中，这个管理权交给了注入器(Injector)，它在软件运行时负责依赖对象的替换，而不是在编译时。这种控制反转，运行注入的特点即是依赖注入的精华所在。 Angular 能通过查看构造函数的参数类型，来得知组件需要哪些服务。 例如， SiteListComponent 组件的构造函数需要一个 SiteService: constructor(private service: HeroService) { } 当 Angular 创建组件时，会首先为组件所需的服务找一个注入器（ Injector ） 。 注入器是一个维护服务实例的容器，存放着以前创建的实例。 如果容器中还没有所请求的服务实例，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular 。 当所有的服务都被解析完并返回时， Angular 会以这些服务为参数去调用组件的构造函数。]]></content>
      <categories>
        <category>angular2</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tslint 与 git pre-commit 配置教程]]></title>
    <url>%2Fblog%2F2018%2F06%2F07%2Ftslint%20git%20pre-commit%20%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[tslint 配合pre-commit的意义为什么用pre-commit 加 tslint（jshint，eslint原理都类似），因为在项目中我们会经常忘记主动的去做代码检查，虽然结合webpack各种构建工具下，存在*slint报错，项目会跑不起来。但在某些情况下，可能会因为着急，或者其他原因，没有去观察项目运行的情况就仓促提交。团队开发的情景下，可能会成为别人的麻烦。而pre-commit tslint解决的需求既是：拒绝向仓库提交错误代码。 git hooks在配置tslint pre commit之前，首先需要了解git hooks，正如它的名字所示，这是一个关于git 操作的钩子，比如我们想要在做远程仓库推送时，那就会触发pre-push这个钩子，然后在这个钩子中写下自己想做的事。git hooks的配置就在项目.git文件夹下面的hooks文件夹中。 在写相关的钩子函数时，需要注意的是，将钩子后面的sample后缀去掉，代码才会生效。 比如，本文中用到的pre-commit这个钩子。 更多关于git hooks的介绍，请参考：https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks 下面介绍如何配置： 配置步骤 打开项目中的.git/hooks文件夹，找到pre-commit.sample文件，将以下代码替换到文件中。 123456789#!/bin/bashTSLINT=&quot;$(git rev-parse --show-toplevel)/node_modules/.bin/tslint&quot;for file in $(git diff --cached --name-only | grep -E &apos;\.ts$&apos;)do git show &quot;:$file&quot; | &quot;$TSLINT&quot; &quot;$file&quot; if [ $? -ne 0 ]; then exit 1 fidone 将pre-commit.sample文件名修改为pre-commit。 此时再打开项目运行git commit -m”xxx”命令时，tslint会做自动的检查，如果没有错误的话，才会提交成功。而存在tslint报错的话，会终止提交。 注意： 日常开发中，有时为了方便会直接使用git commit -am”xxx”（即add+commit）的指令。而pre-commit 只是单独commit 钩子，因此还需要在pre-applypatch这个钩子下去做相同的配置。]]></content>
      <categories>
        <category>tslint</category>
      </categories>
      <tags>
        <tag>tslint</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSLint常用配置及使用方法]]></title>
    <url>%2Fblog%2F2018%2F06%2F06%2FTSLint%2F</url>
    <content type="text"><![CDATA[TSLint核心规则及相关库TSLint已经提供了一些核心规则，但是还不够，于是有人用TSLint提供的自定义接口又自定义了许多规则。如： tslint-eslint-rules——ionic项目默认使用这个 codelyzer——angular项目默认使用这个 还有很多 腾讯团队开源项目tslint-config-alloy现在有了大量校验规则，如何使用如何配置呢。我们使用了腾讯团队的开源项目tslint-config-alloy，它的配置原则： 能够帮助发现代码错误的规则，全部开启 配置不应该依赖于某个具体项目，而应尽可能的合理 帮助保持团队的代码风格统一，而不是限制开发体验 如果觉得tslint-config-alloy提供的配置不合理，我们就可以在本文最开始提到的tslint.json文件(ionic项目根目录下)中覆盖它的配置 如何使用tslint-config-alloy 项目安装依赖：npm install –save-dev tslint-eslint-rules tslint-config-alloy 其中tslint-eslint-rules是规则的实现，它的规则已经继承了tslint，其中tslint-config-alloy是规则的配置，我们的配置继承这里的配置。 配置tslint.json内容如下 其中rulesDirectory指定规则的实现目录，可以配置多个，如你自定义的规则的目录；其中extends指定我们继承的配置，这里继承tslint-config-alloy，我们可以在rules中添加配置和覆盖tslint-config-alloy提供的配置。 123456789101112131415161718192021222324252627282930313233&#123; "extends": "tslint-config-alloy", "rules": &#123; "no-parameter-properties":false, // 禁止给类的构造函数的参数添加修饰符 "triple-equals":false, "no-debugger": false, // 禁止行尾有空格 "no-trailing-whitespace": false, "member-ordering":false, "no-this-assignment": [true, &#123;"allowed-names": ["^self$","^that$"], "allow-destructuring": true&#125;], // 必须使用箭头函数，除非是单独的函数声明或是命名函数 "only-arrow-functions": [ false, "allow-declarations", "allow-named-functions" ], // 禁止出现空代码块，允许 catch 是空代码块 "no-empty": [ false, "allow-empty-catch" ], // 禁止无用的类型断言 "no-unnecessary-type-assertion": false, // 使用 return; 而不是 return undefined; "return-undefined": false, // 禁止对 array 使用 for in 循环 "no-for-in-array": false, "comment-format": [true, "check-space"], // 单行注释格式化规则 &#125;, "rulesDirectory": [ "node_modules/tslint-eslint-rules/dist/rules" ]&#125; tslint代码风格规则和ide默认的格式化代码风格存在冲突如何解决 这时候要么在tslint.json重新定义规则，要么修改ide配置，如： webstorm设置import自动导入的内容为单引号 webstorm设置import自动导入大括号两边添加空格 默认自动生成格式： 1import &#123;AbstractControl&#125; from &apos;@angular/forms&apos;; 想要格式： 1import &#123; AbstractControl &#125; from &apos;@angular/forms&apos;; 其他配置自行百度 实际开发过程中可以先不启用TSLint，每次提交代码前或测试开发的代码时在启用并修复问题 TSLint注释标记 ts文件中使用以下注释来临时忽略规则出现的错误，参考这里 / tslint:disable /——忽略该行以下所有代码出现的错误提示 / tslint:enable /——当前ts文件重新启用tslint // tslint:disable-line——忽略当前行代码出现的错误提示 // tslint:disable-next-line——忽略下一行代码出现的错误提示 常用的tslint配置项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&#123; // 禁止给类的构造函数的参数添加修饰符 "no-parameter-properties": false, // 禁止使用 debugger "no-debugger": false, // 禁止行尾有空格 "no-trailing-whitespace": false, // 禁止无用的表达式 "no-unused-expression": true, // 定义过的变量必须使用 "no-unused-variable": true, // 变量必须先定义后使用 "no-use-before-declare": true, // 禁止使用 var "no-var-keyword": true, // 必须使用 === 或 !==，禁止使用 == 或 !=，与 null 比较时除外 "triple-equals": true, // 指定类成员的排序规则 "member-ordering": false, // 禁止将 this 赋值给其他变量，除非是解构赋值 "no-this-assignment": [ false, &#123; "allowed-names": [ "^self$", "^that$" ], "allow-destructuring": true &#125; ], // 必须使用箭头函数，除非是单独的函数声明或是命名函数 "only-arrow-functions": [ true, "allow-declarations", "allow-named-functions" ], // 禁止出现空代码块，允许 catch 是空代码块 "no-empty": [ true, "allow-empty-catch" ], // 禁止无用的类型断言 "no-unnecessary-type-assertion": true, // 使用 return; 而不是 return undefined; "return-undefined": true, // 禁止对 array 使用 for in 循环 "no-for-in-array": true, "comment-format": [ true, "check-space" ], // 单行注释格式化规则 // 定义函数时如果用到了覆写，则必须将覆写的函数写到一起 "adjacent-overload-signatures": true, // 禁止对函数的参数重新赋值 "no-parameter-reassignment": true, // if 后面必须有 &#123;，除非是单行 if "curly": [ true, "ignore-same-line" ], // for in 内部必须有 hasOwnProperty "forin": true, // 禁止在分支条件判断中有赋值操作 "no-conditional-assignment": true, // 禁止使用 new 来生成 String, Number 或 Boolean "no-construct": true, // 禁止 super 在一个构造函数中出现两次 "no-duplicate-super": true, // 禁止在 switch 语句中出现重复测试表达式的 case "no-duplicate-switch-case": true, // 禁止出现重复的变量定义或函数参数名 "no-duplicate-variable": [ true, "check-parameters" ], // 禁止使用 eval "no-eval": true, // 禁止对对象字面量进行类型断言（断言成 any 是允许的） "no-object-literal-type-assertion": true, // 禁止没必要的 return await "no-return-await": true, // 禁止在数组中出现连续的逗号，如 let foo = [,,] "no-sparse-arrays": true, // 禁止 throw 字符串，必须 throw 一个 Error 对象 "no-string-throw": true, // switch 的 case 必须 return 或 break "no-switch-case-fall-through": true, // 使用实例的方法时，必须 bind 到实例上 "no-unbound-method": [ true, "ignore-static" ], // 使用 &#123; ...foo, bar: 1 &#125; 代替 Object.assign(&#123;&#125;, foo, &#123; bar: 1 &#125;) // 前者的类型检查更完善 "prefer-object-spread": true, // parseInt 必须传入第二个参数 "radix": true, // 必须使用 isNaN(foo) 而不是 foo === NaN "use-isnan": true, // // // 可维护性 // 这些规则可以增加代码的可维护性 // // 禁止函数的循环复杂度超过 20，https://en.wikipedia.org/wiki/Cyclomatic_complexity "cyclomatic-complexity": [ true, 20 ], // 禁止使用废弃（被标识了 @deprecated）的 API "deprecation": true, // 一个缩进必须用四个空格替代 "indent": [ true, "spaces", 4 ], // 禁止出现重复的 import "no-duplicate-imports": true, // 禁止一个文件中出现多个相同的 namespace "no-mergeable-namespace": true, // 文件类型必须时 utf-8 "encoding": true, // import 语句中，关键字之间的间距必须是一个空格 "import-spacing": true, // 接口可以 implement extend 和 merge "interface-over-type-literal": true, // new 后面只必须有一个空格 "new-parens": true, // 类型断言必须使用 as Type，禁止使用 &lt;Type&gt; // &lt;Type&gt; 容易被理解为 jsx "no-angle-bracket-type-assertion": true, // 禁止连续超过三行空行 "no-consecutive-blank-lines": [ true, 3 ], // 禁止使用特殊空白符（比如全角空格） "no-irregular-whitespace": true, // 禁止使用 JSDoc，因为 TypeScirpt 已经包含了大部分功能 "no-redundant-jsdoc": true, // 禁止使用三斜杠引入类型定义文件 "no-reference-import": true, // 禁止变量定义时赋值为 undefined "no-unnecessary-initializer": true, // 小数必须以 0. 开头，禁止以 . 开头，并且不能以 0 结尾 "number-literal-format": true, // 必须使用 a = &#123;b&#125; 而不是 a = &#123;b: b&#125; "object-literal-shorthand": true, // 变量申明必须每行一个，for 循环的初始条件中除外 "one-variable-per-declaration": [ true, "ignore-for-loop" ], // if 后的 &#123; 禁止换行 "one-line": true, // 必须使用单引号，jsx 中必须使用双引号 "quotemark": [ true, "single", "jsx-double", "avoid-template", "avoid-escape" ], // 行尾必须有分号 "semicolon": [ true, "always", "ignore-interfaces" ], // 函数名前必须有空格 "space-before-function-paren": [ true, "asyncArrow" ], // 括号内首尾禁止有空格 "space-within-parens": [ true, 0 ], // 禁止 finally 内出现 return, continue, break, throw 等 // finally 会比 catch 先执行 "no-unsafe-finally": true&#125;]]></content>
      <categories>
        <category>tslint</category>
      </categories>
      <tags>
        <tag>tslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解普通函数中的this及ES6箭头函数的this]]></title>
    <url>%2Fblog%2F2018%2F06%2F06%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[普通函数中的this: this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj 在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成) 在严格模式下,没有直接调用者的函数中的this是 undefined 使用call,apply,bind(ES5新增)绑定的,this指的是绑定的对象 箭头函数中的this箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this 下面通过一些例子来研究一下 this的一些使用场景 首先了解一下作用域链:当在函数中使用一个变量的时候,首先在本函数内部查找该变量,如果找不到则找其父级函数, 最后直到window,全局变量默认挂载在window对象下 全局变量默认挂载在window对象下 在普通函数中,this指向它的直接调用者;如果找不到直接调用者,则是window 123456&lt;script&gt; function test() &#123; console.log(this); &#125; test();&lt;/script&gt; 结果是: window 原因: test()是一个全局函数,也就是说是挂在window对象下的,所以test()等价于 window.test() ,所以此时的this是window 12345678910&lt;script&gt; var obj = &#123; say: function () &#123; setTimeout(function () &#123; console.log(this) &#125;); &#125; &#125; obj.say();&lt;/script&gt; 结果是: window 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window 3.在严格模式下的this 1234567&lt;script&gt; function test() &#123; 'use strict'; console.log(this); &#125;test();&lt;/script&gt; 结果是: undefined 4.箭头函数中的 this 12345678910&lt;script&gt;var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj&lt;/script&gt; 此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window! 示例(多层嵌套的箭头函数): 1234567891011121314&lt;script&gt;var obj = &#123; say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125;&#125;obj.say()&lt;/script&gt; 因为f1定义时所处的函数 中的 this是指的 obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj 示例(复杂情况: 普通函数和箭头函数混杂嵌套) 1234567891011121314&lt;script&gt;var obj = &#123; say: function () &#123; var f1 = function () &#123; console.log(this); // window, f1调用时,没有宿主对象,默认是window setTimeout(() =&gt; &#123; console.log(this); // window &#125;) &#125;; f1(); &#125;&#125;obj.say()&lt;/script&gt; 结果: 都是 window,因为 箭头函数在定义的时候它所处的环境相当于是window, 所以在箭头函数内部的this函数window 示例(严格模式下的混杂嵌套) 123456789101112131415&lt;script&gt;var obj = &#123; say: function () &#123; 'use strict'; var f1 = function () &#123; console.log(this); // undefined setTimeout(() =&gt; &#123; console.log(this); // undefined &#125;) &#125;; f1(); &#125;&#125;obj.say()&lt;/script&gt; 结果都是undefined 说明: 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined! 总结: 使用箭头函数,可以让我们解决一些在匿名函数中this指向不正确的问题; 但是要注意在和普通函数混合的时候,this的指向可能是window !]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3之tabs用法详解,你知道的和不知道的都在这儿]]></title>
    <url>%2Fblog%2F2018%2F06%2F06%2Fionic3_tabs%2F</url>
    <content type="text"><![CDATA[Tabs（选项卡） ion-tabs 在一个 app 中，Tabs 使得在不同页面和功能之间导航更加容易。Tabs 组件，以 的方式写，是单个 Tab 组件的容器。每个 对于 NavControll 来说是公开的组件。 那么tabs有哪些属性和事件呢？下面详细介绍一下: 属性和事件详解 标签 类型 作用 [root] Page 指定tab希望加载的页面 tabTitle string tab上显示的标题 tabIcon string tab上显示的图标 tabBadge string tab上显示的角标数字 tabBadgeStyle string 角标数字的颜色 enabled boolean tab是否可用，默认为true show boolean tab是否显示 [rootParams] object tab上传递的参数 tabUrlPath string 点击tab时跳转的页面url swipeBackEnabled boolean 是否支持滑动后退 tabsHideOnSubPages boolean 在子页面是否隐藏 (ionSelect) 方法 tab select 方法 * 示例html代码如下: 12345&lt;ion-tabs #mainTabs (ionChange)="changeTabs()" color="danger" tabsHighlight="true"&gt; &lt;ion-tab [root]="tab1Root" [rootParams]="homeParams" tabTitle="Home" tabIcon="home"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab2Root" (ionSelect)="selectFriend()" tabTitle="Friends" tabIcon="aperture" tabBadge="3" tabBadgeStyle="danger"&gt;&lt;/ion-tab&gt; &lt;ion-tab [root]="tab3Root" enabled="false" swipeBackEnabled="true" tabTitle="Contact" tabIcon="contacts"&gt;&lt;/ion-tab&gt;&lt;/ion-tabs&gt; * 示例typeScript脚本代码如下： 12345678910111213141516171819202122232425262728293031323334import &#123; Component, ViewChild &#125; from '@angular/core';import &#123; HomePage &#125; from '../home/home';import &#123; AboutPage &#125; from '../about/about';import &#123; ContactPage &#125; from '../contact/contact';import &#123; Tabs, ModalController &#125; from 'ionic-angular';@Component(&#123;templateUrl: 'tabs.html'&#125;)export class TabsPage &#123; @ViewChild('mainTabs') tabRef: Tabs; // this tells the tabs component which Pages // should be each tab's root Page // 为tab标签指定导航至的页面 tab1Root: any = HomePage; tab2Root: any = AboutPage; tab3Root: any = ContactPage; // 指定参数,在tab指向的页面可以读取到该参数 homeParams: any = &#123;user1: 'admin', user2: 'ionic'&#125;; constructor(public modalCtrl: ModalController) &#123; &#125; changeTabs = function () &#123; console.log('tab changed'); &#125;; // 选中tab页后的事件 selectFriend() &#123; let modal = this.modalCtrl.create(ContactPage); // 声明一个modal modal.present(); // 弹出modal &#125; ionViewDidEnter() &#123; let mainTabs = this.tabRef; mainTabs.select(1); &#125;&#125; * home页使用参数示例代码如下： 123456789101112131415161718import &#123; Component &#125; from '@angular/core';// 引入NavParamsimport &#123; NavController,NavParams &#125; from 'ionic-angular';@Component(&#123; selector: 'page-home', templateUrl: 'home.html'&#125;)export class HomePage &#123; // 在这里指定navParams constructor(public navCtrl: NavController,public navParams:NavParams) &#123; &#125; ionViewWillEnter()&#123; // 使用this.navParams.data可以读取tab页传过来的参数 console.log("NavParams:"+this.navParams.data.user1); console.log("NavParams:"+this.navParams.data.user2); &#125;&#125;]]></content>
      <categories>
        <category>ionic3</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>ionic3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3中的gestures 手势事件归档]]></title>
    <url>%2Fblog%2F2018%2F06%2F02%2Fionic3-guestures%2F</url>
    <content type="text"><![CDATA[ionic3中的gestures 手势事件如下：ionic3中的gestures 手势事件包括: tap, press, pan, swipe, rotate, pinch 等事件， tap 点击事件 press 长按事件 pan 滑动的时候触发的事件,滑动触发多次 swipe 滑动事件 滑动触发一次 rotate 旋转事件 pinch 捏合(pinch)手势]]></content>
      <categories>
        <category>ionic3</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>ionic3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3-awesome]]></title>
    <url>%2Fblog%2F2018%2F06%2F01%2Fionic3-awesome%2F</url>
    <content type="text"><![CDATA[简介 About:smiley: ionic3自定义组件及常用例子演示地址。欢迎贡献代码。 技术栈ionic3 + cordova 项目运行12345678910111213git clone https://github.com/artdong/ionic3-awesomecd ionic3-awesome npm installionic serve (运行开发模式)浏览器打开: http://localhost:8080ionic cordova run build android (安卓打包发布)ionic cordova run build ios (安卓打包发布) app演示]]></content>
      <categories>
        <category>ionic3</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>ionic3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic-for100]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2Fionic-for100%2F</url>
    <content type="text"><![CDATA[简介 一个基于ionic的小应用-挑战100。 app演示]]></content>
      <categories>
        <category>ionic</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种方法轻松搞定NodeJS实时编译，动态调试]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2Fnodejs%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Node.js开发中遇到这样的问题总是重新读取并解析脚本(如果没有专门的优化配置)。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。 这时若你修改了js文件，或是调试功能，或是增加功能。这时需要重新发布该服务，每次修改都需要执行以下两步： 12control+cnode server.js 很不爽有木有！因此有人开发了一个自动发布（热发布）的工具，你只需要在修改文件后保存，它就能自动替你发布，这就是所谓的热部署。就像tomcat或websphere等一些主流的web应用服务器那样保存即热部署。下面将介绍两个NodeJS中的开源热部署工具。 (1)supervisorsupervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装 supervisor： 1$ npm install -g supervisor 如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -g supervisor 命令来安装。 接下来，使用 supervisor 命令启动 app.js： 1$ supervisor app.js 命令行窗口会显示启动成功信息，即开启了代码监听。 当代码被改动时，运行的脚本会被终止，然后重新启动。 supervisor 这个小工具可以解决开发中的调试问题。 github地址：https://github.com/isaacs/node-supervisor (2)hotnode首先需要安装，打开NodeJS命令行工具，输入sudo npm -g install hotcode进行全局安装 安装成功后，可以随时查看它的版本号，在命令行输入：hotcode -v 使用很简单，执行命令:hotcode server.js。 每次修改都会有一条日志打印出来。 github地址：https://github.com/saschagehlich/hotnode nodejs + express入门示例nodejs + express入门示例： https://github.com/artdong/node-server]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue移动端框架到底哪家强]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2Fvue%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Weex2016年4月21日，阿里巴巴在Qcon大会上宣布跨平台移动开发工具Weex开放内测邀请。 Weex 是一套简单易用的跨平台开发方案，能以 web 的开发体验构建高性能、可扩展的 native 应用，为了做到这些，Weex 与 Vue 合作，使用 Vue 作为上层框架，并遵循 W3C 标准实现了统一的 JSEngine 和 DOM API，这样一来，你甚至可以使用其他框架驱动 Weex，打造三端一致的 native 应用。 Weex能够完美兼顾性能与动态性，支持iOS、安卓、YunOS及Web等多端部署。 其工作原理 Weex 表面上是一个客户端技术，但实际上它串联起了从本地开发环境到云端部署和分发的整个链路。开发者首先可以在本地像撰写 web 页面一样撰写一个 app 的页面，然后编译成一段 JavaScript 代码，形成 Weex 的一个 JS bundle；在云端，开发者可以把生成的 JS bundle 部署上去，然后通过网络请求或预下发的方式传递到用户的移动应用客户端；在移动应用客户端里，WeexSDK 会准备好一个 JavaScript 引擎，并且在用户打开一个 Weex 页面时执行相应的 JS bundle，并在执行过程中产生各种命令发送到 native 端进行的界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践；同时，如果用户没有安装移动应用，他仍然可以在浏览器里打开一个相同的 web 页面，这个页面是使用相同的页面源代码，通过浏览器里的 JavaScript 引擎运行起来的。 Mint UI基于 Vue.js 的移动端组件库 Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。 真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。 考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。 依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。 vue-carbon基于 vuejs 1.0 开发 material design 风格的移动端 WEB UI 库 使用文档地址 https://myronliu347.github.io/vue-carbon/book/v0.5.0/index.html Muse-UI基于 Vue 2.0 和 Material Desigin 的 UI 组件库 特性 1.组件丰富 Muse UI 基本实现了 Material Design 设计规范类的所有组件，另外还开发许多的功能性的组件 2.可定制 Muse UI 使用less文件，所有的颜色都有一个变量维护，通过编写 less 文件完成自定义主题，另外组件内部也提供一些修改效果的参数 3.基于 Vue 2.0 Muse UI 基于 Vue2.0 开发，Vue2.0是当下最快的前端框架之一，小巧，api友好，可用于开发的复杂单页应用 VUWEvuwe是一款基于微信WeUI所开发的，专用于Vue2的组件库。 它与WeUI完全解耦。用户通过自定义WeUI的样式文件，可以方便地对VUWE实现定制化。 vue-mobilevue-mobile is an UI Framework build with Vue.js for SPA: Full Page Structure - header, content, footer Page transition support by vue-router Bunch of Powerful Components, easy to use and extend high performance CSS3 Animation 1px border for all components - as well as round border Write with Vue - the most important vonic一个基于 vue.js 和 ionic 样式的 UI 框架，用于快速构建移动端单页应用。 和 ionic 的关系：没有关系，只是在样式方面以 ionic 的 css 文件为基础（做了一些调整） vuxVux（读音 [v’ju:z]，同views）是基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面。 基于webpack+vue-loader+vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。 vux-loader保证了组件按需使用，因此不用担心最终打包了整个vux的组件库代码。 vux并不完全依赖于WeUI，但是尽量保持整体UI样式接近WeUI的设计规范。最初目标是创建一个易用，实用，美观的移动端UI组件库，现在离理想状态还有不少距离，因此需要大家及时反馈问题及贡献代码。 即使你不使用vux的代码, 但能从源码得到一些参考那么也是件让人高兴的事情。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular2入门，就这一篇就够了]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2Fangular2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[背景与概念：AngularJS2 是一款开源JavaScript库，由Google维护，用来协助单一页面应用程序运行。 AngularJS2 是 Angular 1.x 的升级版本，性能上得到显著的提高，能很好的支持 Web 开发组件。 AngularJS2 发布于2016年9月份，它是基于ES6来开发的。 Angular2.x与Angular1.x 的区别 Angular2.x与Angular1.x 的区别类似 Java 和 JavaScript 或者说是雷锋与雷峰塔的区别，所以在学习Angular2.x时大家需要做好重新学习一门语言的心里准备。 开工前的准备工作学习AngularJS2前，你需要具备基本的前端基础：HTML、CSS、JavaScript。此外你还需要了解 NPM 及 TypeScript。 Angular 2 架构Angular 2 应用程序应用主要由以下 8 个部分组成： 1、模块 (Modules) 2、组件 (Components) 3、模板 (Templates) 4、元数据 (Metadata) 5、数据绑定 (Data Binding) 6、指令 (Directives) 7、服务 (Services) 8、依赖注入 (Dependency Injection) 下面看每个部分是如何相互工作的： 模板 (Templates)是由 Angular 扩展的 HTML 语法组成，组件 (Components)类用来管理这些模板，应用逻辑部分通过服务 (Services)来完成，然后在模块中打包服务与组件，最后通过引导根模块来启动应用。 接下来对以上 8 个部分分开解析： 1.模块模块又一块代码组成，可用于执行一个简单的任务。 Angular 应用是由模块化的，它有自己的模块系统：NgModules。 每个 Angular 应该至少要有一个模块(根模块)，一般可以命名为：AppModule。 Angular 模块是一个带有 @NgModule 装饰器的类，它接收一个用来描述模块属性的元数据对象。 几个重要的属性如下： declarations （声明）- 视图类属于这个模块。 Angular 有三种类型的视图类： 组件 、 指令 和 管道 。 exports- 声明（ declaration ）的子集，可用于其它模块中的组件模板 。 imports- 本模块组件模板中需要由其它导出类的模块。 providers- 服务的创建者。本模块把它们加入全局的服务表中，让它们在应用中的任何部分都可被访问到。 bootstrap- 应用的主视图，称为根组件，它是所有其它应用视图的宿主。只有根模块需要设置 bootstrap 属性中。 一个最简单的根模块，eg: 1234567891011121314import&#123;NgModule&#125;from'@angular/core';import&#123;BrowserModule&#125;from'@angular/platform-browser';@NgModule(&#123;imports: [BrowserModule],providers: [Logger],declarations: [AppComponent],exports: [AppComponent],bootstrap: [AppComponent]&#125;)exportclassAppModule&#123;&#125; 接下来通过引导根模块来启动应用，开发过程通常在 main.ts 文件中来引导 AppModule ： 123456import&#123;platformBrowserDynamic&#125;from'@angular/platform-browser-dynamic';import&#123;AppModule&#125;from'./app.module';platformBrowserDynamic().bootstrapModule(AppModule); 2.组件(Components)组件是一个模板的控制类用于处理应用和逻辑页面的视图部分。 组件是构成 Angular 应用的基础和核心，可用于整个应用程序中。 组件知道如何渲染自己及配置依赖注入。 组件通过一些由属性和方法组成的 API 与视图交互。 创建 Angular 组件的方法有三步： 从 @angular/core 中引入 Component 修饰器 建立一个普通的类，并用 @Component 修饰它 在 @Component 中，设置 selector自定义标签，以及 template模板 3.模板(Templates)Angular模板的默认语言就是HTML。 我们可以通过使用模板来定义组件的视图来告诉 Angular 如何显示组件。以下是一个简单是实例： 网站地址 : [object Object] 4.元数据(Metadata)元数据告诉 Angular 如何处理一个类。 考虑以下情况我们有一个组件叫作 Component ，它是一个类，直到我们告诉 Angular 这是一个组件为止。 你可以把元数据附加到这个类上来告诉 Angular Component 是一个组件。 在 TypeScript 中，我们用 装饰器 (decorator) 来附加元数据。 12345678910111213141516eg：@Component(&#123;selector : 'mylist',template : '菜鸟教程'directives : [ComponentDetails]&#125;)export class ListComponent&#123;...&#125;` @Component 装饰器能接受一个配置对象，并把紧随其后的类标记成了组件类。 Angular 会基于这些信息创建和展示组件及其视图。 @Component 中的配置项说明： selector- 一个 css 选择器，它告诉 Angular 在 父级 HTML 中寻找一个 标签，然后创建该组件，并插入此标签中。 templateUrl- 组件 HTML 模板的地址。 directives- 一个数组，包含 此 模板需要依赖的组件或指令。 providers- 一个数组，包含组件所依赖的服务所需要的依赖注入提供者。 5.数据绑定(Data binding)数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。 通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。 插值: 在 HTML 标签中显示组件值。 angular2入门，就这一篇就够了 属性绑定: 把元素的属性设置为组件中属性的值。 事件绑定: 在组件方法名被点击时触发。 双向绑: 使用Angular里的NgModel指令可以更便捷的进行双向绑定。 12(input)="currentUser.firstName=$event.target.value" &gt; 6.指令（Directives）Angular模板是动态的 。当 Angular 渲染它们时，它会根据指令对 DOM 进行修改。 指令是一个带有”指令元数据”的类。在 TypeScript 中，要通过 @Directive 装饰器把元数据附加到类上。 在Angular中包含以下三种类型的指令： 属性指令：以元素的属性形式来使用的指令。 结构指令：用来改变DOM树的结构 组件：作为指令的一个重要子类，组件本质上可以看作是一个带有模板的指令。 *ngFor 告诉 Angular 为 sites 列表中的每个项生成一个 标签。 *ngIf 表示只有在选择的项存在时，才会包含 SiteDetail 组件。 7.服务(Services)Angular2中的服务是封装了某一特定功能，并且可以通过注入的方式供他人使用的独立模块。 服务分为很多种，包括：值、函数，以及应用所需的特性。 例如，多个组件中出现了重复代码时，把重复代码提取到服务中实现代码复用。 以下是几种常见的服务： 日志服务 数据服务 消息总线 税款计算器 应用程序配置 以下实例是一个日志服务，用于把日志记录到浏览器的控制台： 12345678910export class Logger &#123;log(msg: any) &#123; console.log(msg); &#125;error(msg: any) &#123; console.error(msg); &#125;warn(msg: any) &#123; console.warn(msg); &#125;&#125; 8.依赖注入控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫”依赖查找”（Dependency Lookup）。 通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 在传统的开发模式中，调用者负责管理所有对象的依赖，循环依赖一直是梦魇，而在依赖注入模式中，这个管理权交给了注入器(Injector)，它在软件运行时负责依赖对象的替换，而不是在编译时。这种控制反转，运行注入的特点即是依赖注入的精华所在。 Angular 能通过查看构造函数的参数类型，来得知组件需要哪些服务。 例如， SiteListComponent 组件的构造函数需要一个 SiteService: constructor(private service: HeroService) { } 当 Angular 创建组件时，会首先为组件所需的服务找一个注入器（ Injector ） 。 注入器是一个维护服务实例的容器，存放着以前创建的实例。 如果容器中还没有所请求的服务实例，注入器就会创建一个服务实例，并且添加到容器中，然后把这个服务返回给 Angular 。 当所有的服务都被解析完并返回时， Angular 会以这些服务为参数去调用组件的构造函数。]]></content>
      <categories>
        <category>angular2</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>angular2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack loader全家桶]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2Fwebpack%20loader%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[webpack的loaders是一大特色，也是很重要的一部分。下面介绍一些常用的loader。 loaders之 js处理babel-loader jsx-loader npm install –save-dev babel-core babel-preset-es2015 babel-loader jsx-loader loaders之预处理css-loader 处理css中路径引用等问题 style-loader 动态把样式写入css sass-loader scss编译器 less-loader less编译器 postcss-loader scss再处理 npm install –save -dev css-loader style-loader sass-loader less-loader postcss-loader loaders之 json处理json-loader npm install –save-dev json-loader loaders之 图片处理url-loader npm install –save-dev url-loader loaders之 文件处理file-loader npm install –save-dev file-loader loaders之 html处理raw-loader npm install –save-dev raw-loader]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不得不知的Ionic3新特性]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2F%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Ionic3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Ionic3新特性： Angular 4.0新的版本下，改进 AOT 编译器，分离 animations 包，缩小生成后的代码量，运行更快，改进ngIf 和ngFor 等具体内容可以访问http://angularjs.blogspot.sg/2017/03/angular-400-now-available.html来查看。 typescript 2.1, 2.2的支持这一次的更新将提升typescript应用构建和类型检查的速度并且引入了对mix-in的支持等具体可以访问https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html来查看。 @IonicPage装饰器ionic2中导航器不是基于url的，如果想使用url访问就要通过DeepLinker来实现，这是非常麻烦的，而在新版本我们可以通过@IonicPage装饰器来实现。并且可以更轻松的在项目中设置延迟加载，设置延迟加载页面的优先级，并为每个页面自定义配置。 懒加载Ionic3.0版本开始，支持了延迟加载，我们可以将某些模块设置为延时加载，只有用户打开相关的页面的时候，这个模块所在的js才会被下载，这样能减少用户初次下载的文件的大小。 总的来说，升级Ionic3将使我们的项目变得更小，更快，而更吸引我们的则是懒加载，不仅仅是加快了app首次的启动时间，更多的是配合上@IonicPage可以非常方便部署web版本，让每次进入不用去请求庞大的js文件，做到首屏的快速加载，write once run anywhere，这些就是我们需要升级Ionic3的原因。 那么，问题来了，怎样升级到Ionic3呢？ 首先访问https://github.com/ionic-team/ionic2-app-base/复制package.json的dependencies和devDependencies到自己的项目中后删除掉原本的node_modules文件夹，运行npm install重新下载依赖。 将BrowserModule加入你的app/app.module.tsimport { BrowserModule } from ‘@angular/platform-browser’;在app.module.ts中将BrowserModule添加进imports中。 1imports: [ BrowserModule, IonicModule.forRoot(MyApp) ], 由于ionic3将ionic-native拆开成个各种小的包@ionic-native/*,splash-screen，status-bar等之前ionic-native中的模块都需要重新引入具体可以参照http://ionicframework.com/docs/native/来对号入座。 最后打开cmd控制台运行ionic serve 开始享受ionic3带来的改变吧！]]></content>
      <categories>
        <category>ionic3</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>ionic3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令清单，非常实用]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2Fgit%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库在当前目录新建一个Git代码库$ git init 新建一个目录，将其初始化为Git代码库$ git init[project-name] 下载一个项目和它的整个代码历史$ git clone[url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置$ git config–list 编辑Git配置文件$ git config-e[–global] 设置提交代码时的用户信息$ git config[–global]user.name”[name]”$ git config[–global]user.email”[email address]” 三、增加/删除文件添加指定文件到暂存区$ git add[file1][file2]… 添加指定目录到暂存区，包括子目录$ git add[dir] 添加当前目录的所有文件到暂存区$ git add. 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交$ git add-p 删除工作区文件，并且将这次删除放入暂存区$ git rm[file1][file2]… 停止追踪指定文件，但该文件会保留在工作区$ git rm–cached[file] 改名文件，并且将这个改名放入暂存区$ git mv[file-original][file-renamed] 四、代码提交提交暂存区到仓库区$ git commit-m[message] 提交暂存区的指定文件到仓库区$ git commit[file1][file2]…-m[message] 提交工作区自上次commit之后的变化，直接到仓库区$ git commit-a 提交时显示所有diff信息$ git commit-v 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit–amend-m[message] 重做上一次commit，并包括指定文件的新变化$ git commit–amend[file1][file2]… 五、分支列出所有本地分支$ git branch 列出所有远程分支$ git branch-r 列出所有本地分支和远程分支$ git branch-a 新建一个分支，但依然停留在当前分支$ git branch[branch-name] 新建一个分支，并切换到该分支$ git checkout-b[branch] 新建一个分支，指向指定commit$ git branch[branch][commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch–track[branch][remote-branch] 切换到指定分支，并更新工作区$ git checkout[branch-name] 切换到上一个分支$ git checkout- 建立追踪关系，在现有分支与指定的远程分支之间$ git branch–set-upstream[branch][remote-branch] 合并指定分支到当前分支$ git merge[branch] 选择一个commit，合并进当前分支$ git cherry-pick[commit] 删除分支$ git branch-d[branch-name] 删除远程分支$ git push origin–delete[branch-name]$ git branch-dr[remote/branch] 六、标签列出所有tag$ git tag 新建一个tag在当前commit$ git tag[tag] 新建一个tag在指定commit$ git tag[tag][commit] 删除本地tag$ git tag-d[tag] 删除远程tag$ git push origin:refs/tags/[tagName] 查看tag信息$ git show[tag] 提交指定tag$ git push[remote][tag] 提交所有tag$ git push[remote]–tags 新建一个分支，指向某个tag$ git checkout-b[branch][tag] 七、查看信息显示有变更的文件$ git status 显示当前分支的版本历史$ git log 显示commit历史，以及每次commit发生变更的文件$ git log–stat 搜索提交历史，根据关键词$ git log-S[keyword] 显示某个commit之后的所有变动，每个commit占据一行$ git log[tag]HEAD–pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件$ git log[tag]HEAD–grep feature 显示某个文件的版本历史，包括文件改名$ git log–follow[file]$ git whatchanged[file] 显示指定文件相关的每一次diff$ git log-p[file] 显示过去5次提交$ git log-5–pretty–oneline 显示所有提交过的用户，按提交次数排序$ git shortlog-sn 显示指定文件是什么人在什么时间修改过$ git blame[file] 显示暂存区和工作区的差异$ git diff 显示暂存区和上一个commit的差异$ git diff–cached[file] 显示工作区与当前分支最新commit之间的差异$ git diff HEAD 显示两次提交之间的差异$ git diff[first-branch]…[second-branch] 显示今天你写了多少行代码$ git diff–shortstat”@{0 day ago}” 显示某次提交的元数据和内容变化$ git show[commit] 显示某次提交发生变化的文件$ git show–name-only[commit] 显示某次提交时，某个文件的内容$ git show[commit]:[filename] 显示当前分支的最近几次提交$ git reflog 八、远程同步下载远程仓库的所有变动$ git fetch[remote] 显示所有远程仓库$ git remote-v 显示某个远程仓库的信息$ git remote show[remote] 增加一个新的远程仓库，并命名$ git remote add[shortname][url] 取回远程仓库的变化，并与本地分支合并$ git pull[remote][branch] 上传本地指定分支到远程仓库$ git push[remote][branch] 强行推送当前分支到远程仓库，即使有冲突$ git push[remote]–force 推送所有分支到远程仓库$ git push[remote]–all 九、撤销恢复暂存区的指定文件到工作区$ git checkout[file] 恢复某个commit的指定文件到暂存区和工作区$ git checkout[commit][file] 恢复暂存区的所有文件到工作区$ git checkout. 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset[file] 重置暂存区与工作区，与上一次commit保持一致$ git reset–hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset[commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset–hard[commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset–keep[commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert[commit] 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他生成一个可供发布的压缩包$ git archive]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Ionic 2]]></title>
    <url>%2Fblog%2F2017%2F03%2F06%2F%E8%AE%A4%E8%AF%86Ionic%202%2F</url>
    <content type="text"><![CDATA[Ionic 2 介绍Ionic 2专注于以标准的HTML、CSS和JavaScript来构建移动站点，并可以通过Cordova打包成移动 App，只需编写一次代码，就可以分别部署到iOS、Android等多种移动平台上。这项技术已经帮助很多开发者创建了很多漂亮的 App。现在Ionic 2已经发布了第二代版本，使移动开发更容易、更有效率。 Ionic 2与一代相比有较大的变化，基于最新的Angular 2，使用TypeScript进行开发，如果您没有接触过 AngularJS或Ionic1.x，完全不用担心，直接从Ionic 2` 开始学习即可。 在使用Ionic 2之前，您应该具备HTML、CSS、JavaScript基础。 2. Ionic2 的优势与不足Ionic 2借助Angular 2的革命性改进，与 1.x 版本相比具有以下优势： 更快的性能Angular 1的检测机制在某些场景下会导致性能降低，由于最初的架构限制已经很难进行提升了。Angular 2有效避免了这种情况。数据显示Angular 2比Angular 1快5到10倍。 官方提供了一个动画来展示Ionic 2的性能提升： 因图片较大，请点击查看: http://blog.ionic.io/wp-content/uploads/2016/09/beta11-vs-beta12.gif 更清晰的项目结构Angualr 2应用是模块化的，因此Ionic 2的项目结构比Ionic 1更为清晰，如： -home.page –home.page.ts –home.page.html –home.page.scss -about.page –about.page.ts –about.page.html –about.page.scss 每个页面的代码、模板、样式都放在一块，意义非常清晰。 更强大的CLIIonic CLI提供了更强大的功能，如添加一个页面，可以使用以下命令： ionic g page NewPage Ionic CLI会生成以下的文件，并且文件中已经生成了基本的代码： -new-page –new-page.ts –new-page.html –new-page.scss Ionic CLI可以生成pages,providers,tabs,pipes,components，directives等。 更友好的页面导航Ionic 2 的导航方式相比一代有了巨大的改进，完全进行了重写。在 Ionic 1.x 中，需要配置路由： .config(function($stateProvider, $urlRouterProvider){ $stateProvider .state(‘home’, { url:’/‘, templateUrl:’templates/home.html’, controller:’HomeCtrl’}) .state(‘main’, { url:’/main’, templateUrl:’templates/main.html’, controller:’MainCtrl’}); $urlRouterProvider.otherwise(“/“); }); Ionic 2抛弃了这种繁琐的方式，更类似原生的开发体验，一行代码即可搞定： this.nav.push(SecondPage); 使用全新的NavController组件，导航栈的操作方式更加方便，实现前进、后退等功能就像操作数组那么简单。 更强大的模板语法Angular 2的模板语法刚接触时可能会觉得有点难以上手，但熟悉之后就能够更加灵活的控制单向绑定、双向绑定、事件绑定等各种功能。 更高效的开发体验 基于TypeScript，使用Ionic 2拥有更好的开发体验，支持类、模块、接口、lambda表达式等新的特性，大大改善了JavaScript的开发体验。当然你需要一个好的编辑器，如VS Code。 强大的智能感知，自定义的类都可以哦，真的有点开发强类型语言的感觉啊 8-) 当然，因为最终还是要依靠Cordova进行打包，因此不可避免的会遇到所有Cordova类跨平台应用面临的问题，在某些性能较差的移动设备上渲染速度较慢。Ionic 2已经明确提出不支持低版本Android设备，并且在Angular 2正式版发布以后，支持AoT编译也会在一定程度上优化 App 性能。 3. Ionic 2 开发基础在开始学习ionic2之前最好能熟悉HTML、CSS及JavaScript，初步了解TypeScript、Angular 2的基础知识，如果了解不深入也没关系，Ionic 2已经为我们隐藏了很多底层的细节，封装的方法意义都很清晰，我们会在实践中，逐步掌握那些奇怪的标签。 Ionic 2基于Angular 2进行构建，这是对于原始版本完全的重写。一些语法和架构都有了变化，开发者需要注意。在Ionic 1中使用的views和controllers等，在Ionic 2中都被合并到了一块。 TypeScript是由微软开发的开源语言，是JavaScript的超集，兼容JavaScript。提供了静态类型、Lambda表达式、接口等先进的概念，可以说是面向对象的JavaScript。2012年10月第一次发行公开版本，目前已经发布了2.0正式版。开发者是大名鼎鼎的Delphi和.NET之父：安德斯·海尔斯(Anders Hejlsberg)。上次大神来华时有幸见过一次，非常和蔼可亲。 AngularJS是由谷歌推出的一款优秀的前端框架，被用于谷歌公司的多款产品中。AngularJS提供了MVVM、模块化、双向绑定、语义化标签、依赖注入等先进思想。AngularJS 诞生于2009年，但是1.x版本在性能上存在诸多问题，谷歌继续发布了颠覆性的Angular 2，目前已经发布了2.0正式版。Angular 2的设计思路与1.x版本是有较大区别的，采用了TypeScript进行开发，因此如果之前没有接触过Angular 1.x的话，可以完全从Angular 2开始。]]></content>
      <categories>
        <category>ionic2</category>
      </categories>
      <tags>
        <tag>ionic</tag>
        <tag>ionic2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs快速搭建web服务]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fnodejs%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[安装nodejs、npm安装成功之后，使用命令测试是否成功： 1234$ node -vv6.10.2 1234$ npm -v5.3.0 初始化项目配置在chat文件夹下执行初始化命令来获取package.json文件，如果你自己能记住也是可以手写的 12345678910111213141516171819202122232425$ npm initpackage name: (20171022)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to C:\Users\Administrator\Desktop\20171022\package.json:&#123; "name": "20171022", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; web服务需要引用的模块http模块(http协议)12$ npm install http --save-dev 12var url = require('http'); Node中提供了http模块，其中封装了高效的http服务器和http客户端http.server是一个基于事件的HTTP服务器，内部是由c++实现的，接口由JavaScript封装http.request是一个HTTP客户端工具。用户向服务器发送数据。 @Helios_nannanblog.csdn.net/woshinannan741/article/details/51357464 url模块(url解析)12$ npm install url --save-dev 1var url = require('url'); This module has utilities for URL resolution and parsing meant to have feature parity with node.js core url module. @npmwww.npmjs.com/package/url fs模块(文件系统)12$ npm install fs --save-dev 1var fs = require("fs"); Node.js 文件系统封装在 fs 模块是中，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX 文件系统操作。 与其他模块不同的是，fs 模块中所有的操作都提供了异步的和 同步的两个版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。我们以几个函数为代表，介绍 fs 常用的功能，并列出 fs 所有函数 的定义和功能。 @平凡www.cnblogs.com/pingfan1990/p/4707317.html path模块(路径解析)12$ npm install path --save-dev 1var path = require("path"); This is an exact copy of the NodeJS ’path’ module published to the NPM registry. @npmwww.npmjs.com/package/path 构建一个基于nodejs的web服务器新建一个index.html 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 新建一个webserver.js 1234567891011121314151617181920212223242526272829303132333435var http = require('http');var fs = require('fs');var url = require('url');// 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log("Request for " + pathname + " received."); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;);&#125;).listen(8081);// 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8081/'); 安装用到的模块到本地项目中： 12345678$ npm install path --save-dev$ npm install fs --save-dev$ npm install http --save-dev$ npm install url --save-dev 安装成功之后执行命令 12$ node webserver 在浏览器起中打开：http://127.0.0.1:8081/ 即可查看效果： ExpressExpress is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. @expressexpressjs.com express API地址：http://www.expressjs.com.cn/4x/api.html 创建一个文件夹express+nodejs，执行初始化项目操作，在项目上安装express 12$ npm install express --save 并且新建index.js、index.html文件 123456789var express = require('express');var app = express();app.get('/', function(req, res)&#123; res.send('hello world2');&#125;);app.listen(3000); 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 在命令行中执行：12$ node index 如果提示listen EADDRINUSE :::3000就说明端口被占用了，可以换成其他端口 123456789101112Error: listen EADDRINUSE :::3000 at Object.exports._errnoException (util.js:1018:11) at exports._exceptionWithHostPort (util.js:1041:20) at Server._listen2 (net.js:1262:14) at listen (net.js:1298:10) at Server.listen (net.js:1394:5) at EventEmitter.listen (E:\工作\workpace\Express\node_modules\express\lib\application.js:618:24) at Object.&lt;anonymous&gt; (E:\工作\workpace\Express\index.js:8:5) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) 在浏览器中打开 http://localhost:3000/ 使用Express加载模版并输出数据未完待续……]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码搭建Hexo站点]]></title>
    <url>%2Fblog%2F2016%2F10%2F23%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BAHexo%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[初始化Hexo模版引擎 一行代码快速搭建Hexo.NexT主题网站，come on，一起来搭建自己的专属blog吧！ 执行安装进入本机E盘，新建blog目录 第一步，安装hexo环境 第二步，安装下载Hexo模版，即初始化Hexo模版 第三步，进入blog文件夹，执行安装依赖包 第四步，启动Hexo服务 第五步，在浏览器中打开http://localhost:4000/ 12345678910npm install hexo-cli -ghexo init blogcd blognpm installhexo server 如果你没有安装npm，请先执行下载安装 安装成功执行 123npm -v 执行以上步骤之后在浏览器中键入http://localhost:4000 即可看到一个初始状态的模版 修改测试端口号如果需要修改端口4000，可以在node-modules文件夹下找到hexo-server模块中的index.js: 12345678910111213141516/* global hexo */&apos;use strict&apos;;var assign = require(&apos;object-assign&apos;);hexo.config.server = assign(&#123; port: 5000,//自行修改端口号 log: false, ip: &apos;0.0.0.0&apos;, compress: false, header: true&#125;, hexo.config.server); 修改之后重新执行hexo server即可: 网站基础配置显示或隐藏Menu菜单在修改菜单之前你首先要弄清楚当前网站使用的皮肤是哪一个，打开网站根目录 config_yml12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 其中landscape就是你的皮肤框架 然后在网站根目录找到themes/landscape这里面就会有你菜单想的配置，同时这里面也有一个 config_yml，为了区分，我们索性把站点下的配置文件称为站点配置yml，皮肤框架下的配置文件称之为皮肤配置yml OK，打开皮肤配置yml你会看到一些简短的配置，其中第一条就是我们的菜单栏配置 12345# Headermenu: Home: / Archives: /archives 修改Home为主菜单，修改Archives为 文章，刷新浏览器http://localhost:5000 即可看到效果 配置站点基础信息打开站点配置yml 1234567# Sitetitle: 标题subtitle: 副标题description: 描述author: 作者language: zh-Hanstimezone: 刷新浏览器 http://localhost:5000 设置rss在站点根目录执行安装hexo-generator-feed 12npm install hexo-generator-feed --save-dev 在站点配置yml中配置插件，为了快速的找到配置项，可以放到文件的结尾 1234567plugins: hexo-generator-feedfeed: type: atom ##feed类型 atom或者rss2 path: atom.xml ##feed路径 limit: 20 ##feed文章最小数量 点击RSS按钮，会出现如下提示，前提是你的浏览器有rss功能，我本地使用的是rss feed reader： 设置本地全局搜索安装下载hexo-generator-searchdb模块12npm install hexo-generator-searchdb --save-dev 站点配置yml需要配置 123456search: path: search.xml field: post format: html limit: 10000 皮肤配置yml需要配置 123local_search: enable: true 当然你会发现并没有起作用，这是因为当前landscape并不支持本地搜索，后续将介绍NexT主题 使用命令生成静态文件您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。生成的文件在网站public目录下 12hexo generate --deployhexo deploy --generate 可缩写为： 12hexo g -dhexo d -g NexT主题下载安装NexT模版在github上下载NexT主题源码 把NexT主题源码的源码整个复制到你的站点目录下的themes/next目录下 修改站点配置yml来更改主题文章上面有讲到，当前我们的主题使用的是landscape需要修改为next 重新启动服务 刷新页面查看效果 学习并使用NexT主题配置打开next的皮肤配置yml，你会看到很多我们不明白的配置项，根据注释可以读出其中配置的含义。 根据语言配置菜单栏语言打开next皮肤配置yml文件，找到languages文件夹 点开zh-Hans.yml其中的配置项就是已经翻译的文本，网站会根据你站点配置yml中的语言配置来去读取对应的语言文件 打开你next皮肤配置yml你会看到菜单栏基础配置： 12345678910menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 发现home和archives菜单是开启的，现在我们全部开启，只需要去掉前面的#，刷新浏览器 12345678910menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat 尝试修改站点配置yml语言，重启服务后刷新浏览器 12language: zh-tw 配置站内搜索安装下载hexo-generator-searchdb模块12npm install hexo-generator-searchdb --save-dev 站点配置yml需要配置 123456search: path: search.xml field: post format: html limit: 10000 皮肤配置yml需要配置 123local_search: enable: true 配置rss配置同见 2.3. 设置rss 配置标签(tags)添加标签其实就是在你的source文件夹下新建一个page页面而已，比如菜单上的tags和about或者categories都是一样的，执行命令 12hexo new page "tags" 会在source目录下生成一个对应的文件夹，其中有index.md文件，打开会看到一些基础配置： 12345---title: tagsdate: 2017-10-24 12:02:51--- 配置分类(categories)12hexo new page "categories" 会在source目录下生成一个对应的文件夹，其中有index.md文件，打开会看到一些基础配置： 1234---title: categoriesdate: 2017-10-24 12:02:51--- 配置站点基础信息配置头像在next皮肤配置yml中可以配置远程地址，也可以是本地资源地址 12345# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: 头像地址 配置站点描述在站点配置yml文件中，找到menu/description就是当前站点的描述 12description: 站点描述 配置第三方跳转链接在next皮肤配置yml中，找到social配置项 12345678910111213social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@163.com || envelope QQ: http://wpa.qq.com/msgrd?v=3&amp;uin=yourqq&amp;site=在线客服&amp;menu=yes || qq #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 友情链接在next皮肤配置yml中，找到links配置项 12345678links_icon: linklinks_title: Linkslinks_layout: inlinelinks: friend1: friend2: friend3: 配置阅读次数（使用第三方服务）leancloud作为装逼神器确实不错，可以随意修改当前文章的阅读次数 12345678# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 使用第三方服务 LeanCloud 查看文章阅读量leancloud_visitors: enable: true app_id: app_key: 配置评论（使用第三方服务）在disqus官网 http://www.disqus.com 注册一个帐号添加应用之后可获得一个名称，作为你的shortname 123456# Disqusdisqus: enable: true shortname: 你的名称 count: true 配置站点统计（使用第三方服务）百度站点统计 http://tongji.baidu.com/web/welcome/login 1234# Baidu Analytics ID# 注意： baidu_analytics 不是你的百度 id 或者 百度统计 idbaidu_analytics: 327573ae29bff3e49a0152fd0be5e1c2 当前文章是否启用评论配置如果不需要当前页面或这文章不启用评论，则只需要添加以下配置： 123456---title: tagsdate: 2017-10-24 12:02:51comments: false--- 自定义配置在每个文章的最后加上版权声明 新建 passage-end-tag.swig 文件 在路径 \themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容可以自定义： 12345678910111213141516171819&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div&gt;&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;ul class="post-copyright" style="margin: 2em 0 0; padding: 0.5em 1em;border-left: 3px solid #ff1700;background-color: #f9f9f9;list-style: none; "&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;本文作者：&lt;/strong&gt; ArtDong &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本博客所有文章除特别声明外，转载请注明出处！ &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig 文件在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添: 1234&#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125;&#123;% endif %&#125; 在next主题配置yml中添加字段 1234# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 结束语跟着我的步骤可以很快的搭建一个属于自己的博客站点，当然hexo.next远远不知这些配置项，有兴趣的同学可以自己看看里面的配置。这篇文章为什么叫一行代码搭建hexo博客呢，哈哈哈，不这样也不会有人看哇，懂hexo的人就不用看了，高手勿喷~另外可以使用翻墙软件在下方评论，写下你想说的话，没有翻墙的，可以直接在站点概述中qq我或者e-mail我都可以。祝，早新手早日玩转hexo博客，这是 博主 的博客，文章不定期更新 NexT官网地址]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
